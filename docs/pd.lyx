#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options false
\language english
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
maidsafe: A new networking paradigm
\end_layout

\begin_layout Author
David Irvine, maidsafe.net limited (registered in Scotland Sc 297540)
\end_layout

\begin_layout Date
April, 2009
\end_layout

\begin_layout Abstract
This paper presents a new way of networking and data handling globally.
 This data centric network is likely to revolutionise the IT industry in
 a very positive fashion.
 for the first time you will be able to walk up to any computer and like
 saying 'you be mine' log in and its your computer, with all your data,
 desktop etc.
 
\end_layout

\begin_layout Keywords
security, freedom, privacy, DHT, encryption
\end_layout

\begin_layout MarkBoth
maidsafe.net limited company confidential Version 0.9
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

...
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Section
Introduction
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Don't panic the section numbering may look different in
\end_layout

\begin_layout Plain Layout
LyX but LaTeX uses the correct Roman numerals and
\end_layout

\begin_layout Plain Layout
Alpha for section counters.
\end_layout

\begin_layout Plain Layout
It's just that LyX doesn't handle counters other than arabic
\end_layout

\begin_layout Plain Layout
numerals.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
PARstart{N}{etworks}
\end_layout

\end_inset

 have grown in popularity over recent years.
 This phenomenon has now spread to all walks of life with the advent of
 the Internet.
 An issue with today's systems is that they require centralised controls
 and data structures.
 This paper describes a method of distributing data in a controlled non-owned
 grid.
 The main elements of the system are: 
\end_layout

\begin_layout Itemize
anonymous or self authentication
\end_layout

\begin_layout Itemize
perpetual data
\end_layout

\begin_layout Itemize
globally distributed Public Key Infrastructure (
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "PKI"
description "Public Key Infrastructure, typically using RSA to create a key pair. The public key is given to anyone and used to encrypt information that is only decrypted by the private key. The public key can confirm the private key of the ID has signed data. A server is usually employed to tie the ID with the public key, this is where errors can happen as keys may be replaced on the server, subverting the whole mechanism."

\end_inset

PKI)
\begin_inset CommandInset citation
LatexCommand cite
key "key-10"

\end_inset


\end_layout

\begin_layout Itemize
self encryption
\end_layout

\begin_layout Itemize
environmentally friendly computing
\end_layout

\begin_layout Itemize
enhanced 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ID"
description "IDentification or IDentifier. In maidsafe these terms are used to describe several indentifiers, including anaonymous, system level and public."

\end_inset

ID theft prevention 
\end_layout

\begin_layout Itemize
data corruption prevention
\end_layout

\begin_layout Standard
maidsafe can be considered a platform rather than a single application and
 on this platform there is the ability for many applications to exist.
 The significant difference from traditional networks and particularly storage
 area networks is that in a maidsafe network people are self policed, network
 controlled, self created and completely unknown, there is however publicaly
 known ID's that can be created by users, however these are separated from
 their login or data management ID's used elsewhere in the network.
\end_layout

\begin_layout Standard
The initial response to the findings of this system are varied and range
 from impossible all the way to this is amazing.
 A point to note is that the systems represented by this paper are at present
 very computer intensive in areas, requires significant bandwidth and may
 appear to be unsustainable, however initial testing proves this not to
 be the case substantively, although it should also be noted we are in a
 state of Moore's Law growth in CPU and possibly faster than this with broadband
 bandwidth and hard drive capacities.
 This area of growth has been exponential over the last decade and the author
 is very aware that the further down a period of exponential growth then
 each passing day brings significantly more CPU, bandwidth and disk space
 than the previous day did.
 As we are nearing the end (if there can be one) of these particular exponential
 growth curves the daily increase 
\emph on
tends towards
\emph default
 infinity.
\end_layout

\begin_layout Standard
Asked recently as part of a paper submission if the maidsafe network was
 sentient, that author replied, it self heals, grows, can segment, calculates
 what to do at any point in time in any area by the actions of many nodes
 current status and is capable of protecting itself, this is a question
 for the reader to decide upon.
\end_layout

\begin_layout Subsection
The Issues Addressed by this Paper
\end_layout

\begin_layout Itemize
Privacy of network individuals (and maintaining net neutrality)
\end_layout

\begin_layout Itemize
Anonymity of browsing and using digital resources
\end_layout

\begin_layout Itemize
Security of data (both retention and theft prevention)
\end_layout

\begin_layout Standard
In Addition
\end_layout

\begin_layout Itemize
ID theft prevention
\end_layout

\begin_layout Itemize
Multi node processing 
\end_layout

\begin_layout Itemize
Hardware problem detection ....
\end_layout

\begin_layout Standard
These are the key issues this paper addresses and it does so as an alternative
 to that offered by existing design.
 Confidence in IT should be close to 100% and this project may assist in
 that shift of thinking for users of technology.
\end_layout

\begin_layout Subsection
Conventions Used
\end_layout

\begin_layout Standard
Client : This is the user interaction component of the system and performs
 most of the synchronous encryption, hashing and key pair generation for
 asynchronous encryption techniques, as well as presenting a user interface
 to the person using the technology.
\end_layout

\begin_layout Standard
Vault : These are simple computer processes that serve chunks, i.e.
 they serve data and do not allow or require login from users.
 The vault process is separate from the client processes and may reside
 on another machine
\emph on
.
\end_layout

\begin_layout Standard
H = Hash function such as SHA or MD5 etc.
 In this case SHA.
\end_layout

\begin_layout Standard
AES = Advanced Encryption System (256) - symmetrical encryption (maidsafe
 uses cfb mode cypher) 
\end_layout

\begin_layout Standard
RSA = Rivest Shamir Adleman (4096) - asymmetric encryption 
\end_layout

\begin_layout Standard
PBKDF2 = Password-Based Key Derivation Function (version2) 
\end_layout

\begin_layout Standard
k = private key (used to decrypt public key encrypted data or to sign data)
\end_layout

\begin_layout Standard
p = public key (used to encrypt)
\end_layout

\begin_layout Standard
\begin_inset Formula $\bigoplus$
\end_inset

= XOR operation
\end_layout

\begin_layout Standard
netputV = put a Value on the network (kademlia)
\end_layout

\begin_layout Standard
netputD = put Data on the network (maidsafe)
\end_layout

\begin_layout Standard
netgetV = get Value from network (kadmelia)
\end_layout

\begin_layout Standard
netgetD = get Data from network (maidsafe)
\end_layout

\begin_layout Subsection
Initial Requirements of System
\end_layout

\begin_layout Standard
There have been many advances over the last 20 years which provide many
 of the facilities required for this system.
 Namely, the Internet, Distributed Hash Tables (from the p2p revolution),
 the widespread use of computers even to the extent of the excellent (One
 Laptop Per Child) OLPC program and finally the rapid adoption and growth
 of available bandwidth, which appears to now be capable of Gigabit and
 Terabit per second in fibre optic links.
\end_layout

\begin_layout Standard
These initial requirements for the new network already being in place, all
 that is needed is a different way to design the whole thing, as though
 we were presented with a situation where computers, broadband, DHT etc.
 were all just newly available.
 The question is glaring, would we have built what we see now? The answer
 is likely a resounding no! So in summary we have:
\end_layout

\begin_layout Enumerate
Processing devices - mostly used less than 5% of capability most of the
 time
\end_layout

\begin_layout Enumerate
Storage devices with an average data element of 22Gb and approx 47% free
 space
\end_layout

\begin_layout Enumerate
Most of these devices connected to a network
\end_layout

\begin_layout Enumerate
Over a billion users and over 700,000,000 connect to the network daily
\end_layout

\begin_layout Enumerate
Many of these devices are on 100% of the time or a significant portion of
 the time and this is growing (with the advent of digital video recorders
 and other computerised home appliances such as sky, tivo etc.)
\end_layout

\begin_layout Enumerate
Devices that are not 100% connected can be largely addressed by today's
 p2p technologies (such as Kademlia routing
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"

\end_inset

) to a greater extent than previously known.
 This paper adds to this concept with the inclusion of a ranking system.
\end_layout

\begin_layout Standard
Given the above parameters it would seem incredible not to design some system
 that made more effective use of the free resources we already have! This
 paper focuses on these resources as the initial building block of the system
 and chooses to ignore centralised or otherwise controlled systems.
\end_layout

\begin_layout Note
Please note the references used throughout this paper do not provide links
 to the source.
 A Internet search will find these documents in their current location.
 This is intentional as dead links tend to stop the user from continuing
 to find the cited document, some references are from the IEEE and will
 require an account.
\end_layout

\begin_layout Subsection
Methodology
\end_layout

\begin_layout Standard
By taking a small proportion of every hard drive's free space and adding
 this together we would have enormous storage.
 In addition the ability to duplicate data across many locations would give
 the ability to ensure data can be monitored and when necessary self repaired
 (by making further copies on disk part (node or computer) failure etc.).
\end_layout

\begin_layout Standard
Take these computers and link them in a way in which everyone benefits and
 does not necessarily have to pay any price would be seen as not only acceptable
 but as a significant benefit.
 To allow people to add data, whatever it may be, and be assured that their
 data is secure and perpetual for as long as they want it is not possible
 today with any reality (as we see from the data loss stories so prevalent).
 It is amazing that this proposed system has taken so long to evolve.
\end_layout

\begin_layout Standard
By using some of this space to store authentication records created by the
 users themselves we could allow self authentication
\begin_inset Foot
status open

\begin_layout Plain Layout
The ability for users to create their own encrypted user identifiers and
 have the network look after these in a manner that's reliable and guaranteed.
 In this way there is no authoritative controls over any person.
 
\end_layout

\end_inset

 This allows security to be not enhanced but altered significantly.
 
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
It is inconcievable that in today's world the implemetation of stronger
 signatures, passwords and even biometric authentication is seen as a security
 enhancement, when in fact it is arguably the opposite! Today authentication
 records are transmitted back to a server or a cluster of servers (regardless
 it is a centralised corporate controlled environement), so imagine in this
 case you use biometric authentication i.e.
 a system reads your finger print, then sends it to an authentication system.
 If this finger print is stolen from that server then the thief not only
 has your password to that system but actually has your finger print, it
 is easy to change a password but not your finger, so the question has to
 be asked again, is that really more secure.
 Now with maidsafe nothing is transmitted back to a central resource, nobody
 knows you have an account, or who you are, so where can a thief steal your
 ID ?
\end_layout

\end_inset


\end_layout

\begin_layout Note
maidsafe or any other software system known today cannot defeat keyboard
 readers (or any device which intercepts keystrokes or other human input
 device).
 maidsafe takes teh view anything digitised is able to be copied, therefor
 it makes sense to limit these situations.
\end_layout

\begin_layout Standard
By allowing self authentication people would be free of corporate controls
 or risks regarding their data protection.
 This could be achieved by users placing random data only they know the
 name of and password protecting that data for later re-validation.
\end_layout

\begin_layout Standard
People may prefer to be in control of their own digital assets and not to
 leave this to corporations.
 
\end_layout

\begin_layout Standard
Interestingly in this design any disk space you donate or are required to
 provide to the network 
\emph on
will not store your data
\emph default
.
 Therefore you give up space for backup and the network stores none of your
 data in that space.
\end_layout

\begin_layout Standard
In the maidsafe network, the network will self-heal and data will move around
 the network to reduce bandwidth usage, remove defunct hardware from the
 network and also to reduce any load on individual nodes.
\end_layout

\begin_layout Standard
Also in this network and perhaps one of the most important facts is that
 a truly distributed network will be created, enabling people to validate
 who they are and undeniably who they are communicating with.
\end_layout

\begin_layout Standard
To understand this more effectively it is best to think of the network as
 follows
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
This project
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Traditional
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Use
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maidsafe layer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
web/email/ftp etc.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Do things
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kademlia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "DNS"
description "Domain Name System, used to convert IP addresses (such as 88.222.43.12) into memorable names such as maidsafe.net, google.com etc. "

\end_inset

DNS 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Find things
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transport
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Therefor it is noted maidsafe does not require ftp, web, email etc.
 and in fact can replace these technologies relatively easily with a faster
 and more secure network, in addition the DNS system that has suffered in
 recent times with capacity issues, phishing (theft and fraud by pretending
 to be another site - using name mangeling or DNS poisining techniques)
 and other attacks is also not required.
 maidsafe also allows data to move freely and cache when in use, this means
 that busy site's or sites under attack actually get replicated and become
 faster rather than slower or failing altogether.
\end_layout

\begin_layout Section
Existing Technology Employed 
\end_layout

\begin_layout Subsection
The Network Layer
\end_layout

\begin_layout Subsubsection
Transport Layer Communications
\end_layout

\begin_layout Standard
maidsafe employs a transport that is UDP (User Datagram Protocol) based,
 although as data transfer at the MAID layer requires reliability a TCP
 (Transmission Control Protocol) emulation layer is employed.
 This allows unreliable communications and firewall penetration (via hole
 punching, UPNP, NAT-PMP etc.) at the basic network layer (UDP) and also
 for small kadmelia messages.
 As the maidsafe layer requests reliability in sending data a TCP emulation
 layer is required, this was initially an air-hook implementation but more
 recently greater success has been with UDT
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Distributed Hash Table (DHT)
\end_layout

\begin_layout Standard
The DHT is used in maidsafe technology as a key/
\emph on
value
\emph default
 pair.
 storage area i.e.
 we store a hash key and associate 
\emph on
values
\emph default
 with it.
 The intelligence of the Kademlia
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"

\end_inset

 DHT is that it distributes these key 
\emph on
value
\emph default
 pairs throughout a network in a manner that's very fast to look up (using
 an XOR mechanism).
 So we can store apple:
\emph on
fruit
\emph default
 as a key and value and we could add several values to the key like apple
\emph on
:core
\emph default
 etc.
 so the key apple would yield values
\emph on
 fruit
\emph default
 and 
\emph on
core
\emph default
.
 All we do is store a key and value â€“ we do not need to understand where
 it is, it is just stored.
 We can also check a key exists i.e.
 when we want to create an ID we can check for uniqueness by querying the
 DHT if required.
\end_layout

\begin_layout Subsubsection
DHT Tuning
\end_layout

\begin_layout Standard
Kademlia, like most DHT's can be tuned to affect performance, namely reliance
 to churn over bandwidth used and local processing power (although this
 is relatively small).
 A good example of this is cited in section 4.2 of 
\begin_inset CommandInset citation
LatexCommand cite
key "key-7"

\end_inset

 and also well researched in 
\begin_inset CommandInset citation
LatexCommand cite
key "key-16"

\end_inset

.
 These papers should be read in order to understand the workings of Kademlia
 (alongside 
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"

\end_inset

 of course).
 A particularly good example of trade-offs in tuning networks was written
 by Jun Xu 
\begin_inset CommandInset citation
LatexCommand cite
key "key-8"

\end_inset

 and efficient selection of Kademlia in this case to give 
\begin_inset Formula $O\log_{2^{b}}n$
\end_inset

 distance for the routing table as described by Jun yields the most efficient
 routing table size in the trade-off between bandwidth and efficiency.
\end_layout

\begin_layout Subsection
Filesystem Layer
\end_layout

\begin_layout Standard
The filesystem layer is presented here as the user interface, although the
 system has in fact 2 user interfaces in reality, the fuse interface and
 a graphical user interface to provide the login screen and amongst others
 the messaging screen, vault management, contacts etc.
\end_layout

\begin_layout Subsubsection
FUSE (File System In UserspacE)
\end_layout

\begin_layout Standard
The filesystem presented to the user has to be one which is controlled by
 the maidsafe client process and populated from the users own datamap, whilst
 at the same time only appearing to have all the users data actually there
 (otherwise download all data all the time limits the system).
 for this purpose a FileSystem in userspace was required.
 The chosen system is slightly different for each tier1 operating system
 Linux has FUSE, MAC OSX has MACFUSE and Windows has Dokan.
\end_layout

\begin_layout Standard
All of these have a very similar API (Application Programming Interface)
 and allow files to be presented to the user by supplying directory structures
 and certain flags, such as file size, name, type, attributes etc.
 
\end_layout

\begin_layout Standard
These systems are all kernel level components and as such allow us to present
 a full filesystem to the user as a mounted drive (similar to a usb drive)
 where users can browse the drive like any other drive on their computer.
 this device is a software device and as such we can allow an infinite amount
 of data to be present on it.
 Any application accessing the data believes this is a normal filesystem
 and treats it as such.
 Underneath this the maidsafe client software is retrieving bits of data
 and reconstituting pieces or whole files on request and at the same time
 may be chunking encrypting and storing data saved to this drive, all invisibly
 to the user.
\end_layout

\begin_layout Subsection
MAID layer
\end_layout

\begin_layout Subsubsection
Data Serialisation, Transfer and RPC system
\end_layout

\begin_layout Standard
In the maidsafe layer data is continually being serialised and sent across
 the network and messages containing requests and responses are being transferre
d.
 To accomplish this there are generally many serialisation options available.
 The option chosen here is 'protocol buffers' which is an open sourced project
 from Google (many Google components are used by maidsafe, including coding
 standards, test framework etc.).
 These allow data to be serialised based on templates known as proto files
 which are compiled into native c++ code which the programmer can use to
 write and read serialised data in a very efficient manner.
 
\end_layout

\begin_layout Standard
XML was considered but rejected as the overhead was too high for a system
 where the data end points can be so tightly controlled.
 Interconnection to the maidsafe API would not likely include data transfer
 issues and therefor the data serialisation would be considered a private
 matter to the system and not required to be exposed at the API level, otherwise
 XML may have some language agnostic capabilities making it more appealing.
 
\end_layout

\begin_layout Section
System Building Blocks
\end_layout

\begin_layout Subsection
Generic BUFFER Packet
\begin_inset CommandInset label
LatexCommand label
name "sub:Generic-BUFFER-packet"

\end_inset


\end_layout

\begin_layout Standard
An important building block for the system depends on what we call buffer
 packets.
 These packets can be data chunks, stored on the vaults in a data form and
 referenced from the DHT key,value pair.
 For the purpose of simplicity here we depict the buffer packet as a value
 in the key value pair.
 
\end_layout

\begin_layout Standard
We have known keys in the DHT key value pair such as PMID, MPID, MAID etc.
 which hold differing information such as public keys etc at the moment.
 Knowing these keys means we can know of the existence of buffer keys by
 some hashing (i.e.
 to send to a buffer packet for DAVID would be H(DAVIDBUFFER)) - now we
 have the hash of the PMID for example as a key H(PMID) which we can easily
 find given a known PMID.
 If we want a buffer packet we append the work BUFFER to the PMID and hash
 it.
 We can then find this key easily with H(PMID+BUFFER), this is true for
 all known ID's we have on the network.
\end_layout

\begin_layout Standard
The content of these keys (i.e.
 the values) are defined as follows for a particular owner of the buffer
 packet with relation to the senders to this buffer packet.
 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Sign(ID's\, allowed\, or\, ALL)_{[PMID]}$
\end_inset

 (This signature allows the owner (PMID) to delete or remove content from
 the value.
 It also identifies which ID's can store information here)
\end_layout

\begin_layout Itemize
\begin_inset Formula $Sign(RSAencrypt(message)_{[PMID]})_{[senders\; ID]}$
\end_inset

 (signed with senders ID and encrypted with owners public key)
\end_layout

\begin_layout Itemize
\begin_inset Formula $Sign(RSAencrypt(message)_{[PMID]})_{[senders\; ID]}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Sign(RSAencrypt(message)_{[PMID]})_{[senders\; ID]}$
\end_inset


\end_layout

\begin_layout Itemize
...May be repeated !
\end_layout

\begin_layout Standard
If this buffer becomes too full then an actual data chunk is created and
 the values of where the data chunk is stored is added here.
 The data chunk has the same parameters as this value and acts in the same
 way.
 This data chunk will be created by the next person wishing to save a message
 and the value added as the last entry on the list.
 In PD we can limit this buffer to 500Kb or some other figure decided preferably
 by the network.
\end_layout

\begin_layout Standard
A special entry in the buffer packet 
\begin_inset Formula $RSAsign(Online\: IP:PORT:RVIP:RVPORT)_{[PMID]}$
\end_inset

 may be set which tells other nodes trying to communicate that the end node
 is actually on line at the relevant IP and UDP Port (the RV IP and port
 are described later), in this case the censoring or filtering of messages
 is handled at the node itself, which will silently drop all non authorised
 messages.
 This can be enhanced by creating a share like scenario where a key pair
 is created and the users passed the public key to decrypt this location,
 or even a password is created for nodes to decrypt this information if
 synchronous encryption is decided to be a better option here.
\end_layout

\begin_layout Subsubsection
Watch List
\end_layout

\begin_layout Standard
The watch list is a special type of buffer packet.
 The watch list is a list of 50 ID's that are all self signed.
 The ID's are the MAID ID's and are not linked to the user ID or public
 ID and are only used to save data and request delete of data chunks.
 This list may eventually be encompassed in the rank packet described later.
 
\end_layout

\begin_layout Subsection
Create a Generic ID 
\begin_inset CommandInset label
LatexCommand label
name "sub:Create-an-ID"

\end_inset

 (e.g..
 MAID, ANMID, ANTMID etc.)
\end_layout

\begin_layout Standard

\emph on
MAID, ANMID, ANMAID, ANTMID, ANMPID
\emph default
 are examples of this computation (note 
\emph on
MPID
\emph default
 and PMID are NOT !)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSAgenkeypair_{()}\equiv(k_{[]},p_{[]})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $RSAsign(k)_{([p])})\equiv P_{s}$
\end_inset

(signed so it can be deleted by owner)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $SHA(P_{s})\equiv ID$
\end_inset

 (ensures content must meet this criteria)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $netgetV(ID)\equiv NIL$
\end_inset

 (To ensure uniqueness, or back to 1)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netput{\scriptstyle D{\scriptscriptstyle _{[ID]}{\textstyle (}{\textstyle p_{s}{\scriptstyle )}}}}$
\end_inset

 (ID packet, stored)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula ${\scriptstyle }$
\end_inset

Store k and ID in the private key chain 
\begin_inset Formula $\hat{P}$
\end_inset

 of the DA for later use
\end_layout

\begin_layout Subsection
Public Key Infrastructure (PKI) 
\end_layout

\begin_layout Standard
To check an ID that has apparently signed a request.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $netgetD(ID)$
\end_inset


\end_layout

\begin_layout Enumerate
Read content (public key)
\end_layout

\begin_layout Enumerate
Confirm signature (using standard PKI rules, check privately signed data
 with the public key of the id used)
\end_layout

\begin_layout Standard
The issue is that unless the public keys are protected in that they cannot
 be altered such a system would fail, as any cracker could essentially replace
 the public key and then pretend to be the ID.
 In maidsafe this is made impossible using protection mechanisms from deleting
 MPID packets as shown in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Public-ID-MPID"

\end_inset

.
 maidsafe also provides anti fraud mechanisms by having all users copy all
 public keys from MPID they communicate with.
 Thereby fraudsters would create system alerts by trying to replace this
 key.
 This gives the owner an opportunity to re-save the key onto the maidsafe
 network.
 (anti Sybil attacks!)
\end_layout

\begin_layout Standard
This gives us a distributed validated and updated PKI infrastructure, with
 one proviso, we require that these chunks are not tampered with and that
 is where we use SHA.
 The SHA of many ID keys is the chunk name and also the ID associated with
 the chunk.
 With ranking and perpetual data this ensures the chunk is valid as any
 chunk on the maidsafe network.
 These anonymous chunks can sign non anonymous chunks happily and then only
 they can delete them (signing is built into chunk name - cannot be retrospectiv
e, i.e.
 you could not (given today's technology) create a key pair that creates
 the same resulting hash name, so fraud would be computationally near impossible
).
 This is described In Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Alg-PKIID=SHA512Hash(RSA[pub]+Signed-[RSA[priv]])"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Alg-PKIID=SHA512Hash(RSA[pub]+Signed-[RSA[priv]])"

\end_inset

system ID=(SHA512Hash(Public_Key+Signature [Signed_by_some[priv]]))
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we have well formed chunks and a validity check we can be assured the
 public key we get is the key that was saved in that chunk and has not been
 tampered with.
 The MPID and similar keys are very small and stored on trustworthy machines
 (or high-ranking machines as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Rank-Packets-(or"

\end_inset

) in perpetuity.
 
\end_layout

\begin_layout Standard

\emph on
This is a self regulating and managing global PKI infrastructure.
\end_layout

\begin_layout Subsection
System Packet Structure
\end_layout

\begin_layout Standard
Every system chunk is signed (
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "RSA"
description "Rivest Shamir Adleman  asymmetric\\\\encryption\\\\"

\end_inset

RSA 4096) with a private key and is named using differing conventions.
 These are : 
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MID"
description "A packet used to identify a unique user upon login, derived from their username and PIN (personal identification number)."

\end_inset

MID 
\begin_inset Formula $Sign(\mathcal{MID}content)_{[ANMID]}$
\end_inset


\emph default
 
\end_layout

\begin_layout Standard
Content == random number signed by ANMID
\end_layout

\begin_layout Standard
ID == H(U+P)
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "SMID"
description "[Surrogate maidsafe IDentification] A surrogate MID packet used to ensure MID integrity during an update (write after update)."

\end_inset

SMID
\emph default
 
\emph on

\begin_inset Formula $Sign(\mathcal{SMID}content)_{[ANSMID]}$
\end_inset


\emph default
 
\end_layout

\begin_layout Standard
Content == random number signed by ANSMID
\end_layout

\begin_layout Standard
ID is H(U + P + 1).
 
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MAID"
description "[maidsafe Anonymous IDentification] An anonymous <key,value> pair used to store data on the network privately and also used to control the PD Vault. "

\end_inset

MAID
\emph default
 
\emph on

\begin_inset Formula $Sign(\mathcal{MAID}content)_{[ANMAID]}$
\end_inset


\emph default
 
\end_layout

\begin_layout Standard
Content == Public Key signed by 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ANMAID"
description "Anonymous MAID keypair, this keypair is never used for anything other than sign the MAID packet and delete it again if necessary. The private key is never transmitted or used in any other situation. This is a safe keypair in that it's used with extreme caution and therefor extremely unlikely to be stolen or otherwise comprimised."

\end_inset

ANMAID
\end_layout

\begin_layout Standard
ID == H(content)
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "TMID"
description "[Temporary maidsafe IDentification] An ever changing chunk (at every session update) which holds the data map of the data atlas (i.e. a database of all stored files)."

\end_inset

TMID
\emph default
 
\emph on

\begin_inset Formula $Sign(\mathcal{TMID}content)_{[ANTMID]}$
\end_inset


\emph default
 
\end_layout

\begin_layout Standard
Content == (data map of data atlas) encrypted using users password signed
 by 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ANTMID"
description "Anonymous TMID keypair, this keypair is never used for anything other than sign the TMID packet and delete it again if necessary. The private key is never transmitted or used in any other situation. This is a safe keypair in that it's used with extreme caution and therefor extremely unlikely to be stolen or otherwise comprimised."

\end_inset

ANTMID
\end_layout

\begin_layout Standard
ID = H(content) 
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MPID"
description "[maidsafe Public IDentification] A special packet which creates a user identity that is public. This packet is not linked with any other in the system, i.e. there is no link between this and login or data storage and retrieval. It can be considered to be a publicly viewable name (e.g. printed on a business card) that gives no clues to the user's system credentials. "

\end_inset

MPID
\emph default
 
\emph on

\begin_inset Formula $RSAsign_{[\mathcal{ANMPID}]}(\mathcal{MPID}content)$
\end_inset


\emph default
 
\end_layout

\begin_layout Standard
Content == Public Key signed by 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ANMPID"
description "Anonymous MPID keypair, this keypair is never used for anything other than sign the MPID packet and delete it again if necessary. The private key is never transmitted or used in any other situation. This is a safe keypair in that it's used with extreme caution and therefor extremely unlikely to be stolen or otherwise comprimised."

\end_inset

ANMPID
\end_layout

\begin_layout Standard
ID == H(public name)
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "PMID"
description "[Proxy maidsafe IDentification] A packet named with the hash of the Vault's public key signed by the owners MAID, and which is linked to the MAID. By linking the vault and the client, it allows the client to store data directly by signing requests with this PMID key. The PMID keypair is created by the client."

\end_inset

PMID
\emph default
 
\emph on

\begin_inset Formula $RSAsign_{[\mathcal{MAID}]}(\mathcal{PMID}content)$
\end_inset


\end_layout

\begin_layout Standard
Content == Public key signed by MAID 
\end_layout

\begin_layout Standard
ID == H(content)
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MSID"
description " [maidsafe Shared IDentification] A private share data map held locally and updated on the network via messages."

\end_inset

MSID
\emph default
 - (private share data map held locally and updated on the network via messages)
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "PPMID"
description " [Purchasable Proxy maidsafe IDentification] A packet used to maintain a list of disk space which may be allocated by Maidsafe to others either at a cost or by donation, etc. This is used in the pdzone registration process."

\end_inset

PPMID
\emph default
 - Purchasable Proxy maidsafe ID - Used to maintain a list of disk space
 which may be allocated by maidsafe to others either at a cost or donation
 etc.
 This is used the the pdzone registration process.
\end_layout

\begin_layout Standard
To maintain separation of the packets from any linked information they are
 all signed by an anon ID and these ID's are named ANMID ANMAID etc.
 with the exception of the PMID which is signed by the MAID.
 The reason for this is the MAID and PMID are linked and this signature
 links them.
 The one way signature (MAID->PMID) and not the other way around is a measure
 of security in case of vault failure or intrusion possibilities.
 The MAID security measures are stored securely on the network but the PMID
 private key is contained at the vault location.
 The system can unauthorise a vault via the MAID ID if there are any security
 issues at the vault.
 This is a fail-safe measure to ensure integrity of data as the PMID chunk
 on the network can be deleted and a new one created on failure of any kind
 on the vault.
\end_layout

\begin_layout Standard
In future there will be the followng two additional system packets.
 
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MMID"
description "[Moving maidsafe IDentification] A version 2 MID packet which continually alters its name to further mask the user's ID."

\end_inset


\emph default
MMID : 
\emph on

\begin_inset Formula $RSAsign_{[\mathcal{ANMID}]}(\mathcal{MID}content)$
\end_inset


\emph default
 , ID = hash ((username + pin + Date))
\end_layout

\begin_layout Standard

\emph on
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "MSMID"
description "[Moving Surrogate maidsafe IDentification] A version 2 SMID which continually alters its name, making guessing a username pin combination statistically very improbable, and with today's technology, mathematically impossible."

\end_inset


\emph default
MSMID 
\emph on

\begin_inset Formula $RSAsign_{[\mathcal{ANSMID}]}(\mathcal{SMID}content)$
\end_inset


\emph default
 = This is the movable surrogate MID packet used to ensure MID integrity
 during an update (write after update).
 Again this ID is the H(U + P +1 + date) hashed.
\end_layout

\begin_layout Section
Distributed Hash Table
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Note
This section assumes the reader has read the kademlia paper referenced in
 this section as repleating the details is not of value here.
\end_layout

\begin_layout Standard
In a standard hash table you could consider a simple two column database
 where column 1 is a hash and column 2 is the value.
 This is in fact how a hash table works.
 Normally the hash is a calculable value which produces a key and with this
 key the data or value is retrieved from the hash table.
 
\end_layout

\begin_layout Example
If we have some fruits, say apple, orange and pears and we stored the number
 of these items in a hash table then it's done by taking a hash of the name
 apple, orange or pear and creating a record with the hash as key and the
 number of the fruit as the value.
 If later we wish to find out some information about the apples we hash
 apple and look up the value against this key (in this case number left
 in store).
\end_layout

\begin_layout Example
maidsafe, however, does something different (as you may expect) and actually
 stores content in many cases which is the value and this value hashes to
 the key! This seems backwards as if you have the value already, why hash
 it to look up the value? Well in maidsafe we don't have the value we have
 only the key(as normal) but we know the value we get will hash to the key.
 This is where we use the hash technique to our advantage.
 We know the value we retrieve will hash to the key but we don't know what
 the value is (this is empirical in hash techniques, one way mathematical
 algorithm to produce fixed length hashes).
 
\end_layout

\begin_layout Example
The reason for this is twofold, initially the value is generally a large
 chunk of data we cannot hold ourselves as it would be too large (consider
 we may have several million keys per user, adding to several exabytes of
 data if the values were all local).
 Secondly the security of a distributed system is paramount, as you do not
 have access to the machines the data is on you require a mechanism to ensure
 that the data you get back is valid and not tampered with, maidsafe does
 many different checks on this, but there is a final user Check available
 and this is to ensure the value hashes to the key!
\end_layout

\begin_layout Example
So maidsafe uses kademlia to store keys and values as well as routing informatio
n, but uses an overlay network (maid layer) to ensure data robustness (explained
 in Vaults section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Vaults"

\end_inset

) and integrity, as described and also further detailed in Vaults section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Vaults"

\end_inset

.
\end_layout

\begin_layout Subsection
Distributed
\end_layout

\begin_layout Standard
As described a hash table is a relatively simple concept and can be thought
 of as a mere two column database.
 The power of distributed hash tables takes this further by splitting the
 actual database over multiple locations.
 These locations are in themselves hash keys, usually in the same address
 space as the values (but this is not a requirement).
 The distinguishing factor here is what request for the data is made (in
 the case of Kademlia a FIND_NODE is an address look-up and FIND_VALUE is
 a data (or value) look-up).
\end_layout

\begin_layout Standard
The basic process is to find a value in Kadmelia the search congregates
 on the nodes closer and closer to the value being searched (like a find
 node) and when a node with the value (which may be very far away from the
 value) has the value it replies to the FIND_VALUE with the actual value.
 In opposition to a FIND_NODE where merely closer and closer nodes are returned
 (there is no value in this case) until some node has no details closer
 than requested.
 This is then the closest node unless others returned in the alpha replies
 are closer.
 In the case of find_node the answer is closest node whereas find_value
 is the actual value being searched.
 
\end_layout

\begin_layout Subsection
Kademlia
\end_layout

\begin_layout Standard
maidsafe utilises Kademlia
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"

\end_inset

 as the Distributed Hash Table (DHT) of choice.
 This was considered alongside Chord, Chord2, Tapestry and many others.
 Kademlia was chosen as it presented the most random method of distribution
 of nodes and using the XOR searching criteria allowed very fast network
 resolution.
 This is clearly identified and described in the paper
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"

\end_inset

.
 
\end_layout

\begin_layout Standard
Standard kademlia, though, has some limitations and an example of some limitatio
ns are:
\end_layout

\begin_layout Itemize
susceptible to node failures causing bad routing information to be propagated
 for a longer time than necessary
\end_layout

\begin_layout Itemize
whilst relying on a balanced routing table match the balanced binary tree,
 standard kademlia does not put any favour on closer nodes being more important
 (examination of the binary tree routing algorithm will quickly show the
 closest nodes are more important than the very sparse further away (XOR
 distance)) nodes.
 Kademlia does recodnise the closer more important nodes, in it's standard
 for it does not assist these nodes in any way.
\end_layout

\begin_layout Itemize
Potential 'race conditions' in republishing values between the k closest
 nodes to any particular value.
 This is a situation where a value is republished and all k nodes then decide
 to republish in a given interval, it is obvious that they will all republish
 at interval n after a republish is seen.
 This means all nodes may in fact be crossing over each others republish
 times, causing the race.
\end_layout

\begin_layout Standard
These first three potential issues are addressed and analyzed in a paper
\begin_inset CommandInset citation
LatexCommand cite
key "key-16"

\end_inset

.
 These additions have been recodnised and improved upon by maidsafe in creating
 perpetualdata.
 Further issues with Kademlia and DHT's in general is the ability to amend
 (or delete) values after publishing.
 This is due to the inherent distributed nature of the values (as the name
 suggests).
 As values are distributed in a pseudo random manner (mathematically predictabil
ity becomes an issue due to the large amount of variables (routes, nodes,
 node names, locations etc.) and random human input).
 
\end_layout

\begin_layout Note
Random here is used to indicate not computationally recodnisable with today's
 resources.
\end_layout

\begin_layout Note
Searches on Kademlia networks are very fast and iterative (
\emph on
not recursive
\emph default
) this means that each node will ask some nodes a question get answers (hopefull
y) and from the answers construct a new node list to ask.
 If this were recursive then a failed node would halt the process, as this
 is iterative then failed nodes simply timeout whilst the search continues
 (this is the 
\begin_inset Formula $\beta$
\end_inset


\begin_inset Formula $\mbox{}$
\end_inset

 (required replies to continue) requirement, from the 
\begin_inset Formula $\alpha$
\end_inset

 (parallel level) searches).
 As kademlia uses a binary tree and XOR searching the search time per iteration
 is 
\begin_inset Formula $\mathcal{O}\ln n$
\end_inset

 (where big O is network latency and a factor of XOR distance between node
 id's (holes in address space) and n is number of nodes, not number of possible
 nodes) this figure can be improved upon by the additions shown so far.
 Further examination of the big O constant may lead to further improvements
 in search completion times by not only using decreasing distance but also
 decreasing distance with path protection (multiple routes protected) by
 examination of xor distance between parts of the network particularly where
 there is binary imbalance in early days.
 
\end_layout

\begin_layout Subsection
Value Handling
\end_layout

\begin_layout Standard
In Kademlia there are several methods of ensuring values are consistent
 and protected at the same time.
 The initial value to be considered is K and this should be chosen to be
 the number of random nodes that can be allowed to go off line in a Refresh
 (Refresh) time.
 Also there is a republish time (Repub) which is the initial store of the
 value and sets a time to live (TTL) value on the data.
 
\end_layout

\begin_layout Subsubsection
Caching
\end_layout

\begin_layout Standard
In kademlia values are cached distant from their natural location of the
 K closest nodes.
 The TTL is used in this instance to calculate how long a value can live
 and the further away from the K closest determines the TTL value that each
 value has.
 This value is chosen as the reciprocal of the distance from K of the value
 (so 2 steps away the TTL is halved and 4 steps the TTL is quarter etc.).
 
\end_layout

\begin_layout Standard
This can present issues when the refresh time (usually 60 mins but configurable)
 is due.
 In this case the node must check it's in the K closest and if so refresh
 (i.e.
 send a store_value) the K closest nodes.
 If a node is not in the K closest then this store RPC should not be sent,
 unless all of the K closest nodes do not have the value and the TTL has
 not expired, in this case only a node with a value which is not in the
 k closest group will republish (the true TTL so reverse of inverse reciprocal)
 to the K closest.
 In maidsafe Beta refresh is used to vary in an evenly distributed way the
 60 minute intervals to reduce potential for race conditions in republishing
 values.
 If a value is deleted the closest nodes with the value (k closest) should
 be updated with a -1 value and this should not be cached, this prevents
 cached copies actually republishing values that are due to be removed anyway
 (i.e.
 ignoring or overriding the delete instruction)
\end_layout

\begin_layout Subsubsection
Time To Live Values
\end_layout

\begin_layout Standard
The TTL can be different for any different type of file from seconds to
 a figure meaning do not delete ever (i.e.
 -1).
 For fast changing data the TTL should be small and for unchanging data
 (like digital keys) the TTL may be very large or even infinite (relatively).
 This value is reset only by the storing node unless another algorithm for
 that value type is known by the kademlia node i.e.
 in the case of vault validity check, it will be by one of the identified
 kadmelia ID's watching the chunk, so the vlaue will hold the ID's allowed
 to republish the data (also the ID will be allowed to delete himself from
 the list but not the others).
 Using this mechanism maidsafe uses a 24hr period for reference pointers
 and a 60 day period for signature packets, which will also republish these
 kademlia values in case of error etc.
 at every validity check, this is done simply as a speed up as kademlia
 values are retrieved much faster than maidsafe data.
\end_layout

\begin_layout Subsection
Delete or modify values
\end_layout

\begin_layout Subsubsection
Description
\end_layout

\begin_layout Standard
As previously stated modifying a value in a distributed hash table is notoriousl
y difficult.
 This is endemic in the very nature of the pseudo random distribution of
 data in such a network (the DHT strength is one of the largest weaknesses
 here).
 If a single value is altered via any method which may even include checking
 digital signatures or passwords etc.
 many methods can be dreamed up for this, the value itself may exist in
 many places and it's finding these places that's the problem.
 We have already seen the distribution as random, therefor this assumes
 you would require to search every node in the network (not only closest)
 for copies and make sure there also altered.
 To make this even more difficult, another node may also be alerting the
 value at the same time, thereby causing chaos in the synchronising of data
 on the network, eventually leading to total collapse.
\end_layout

\begin_layout Standard
This is not really all that very good for many networks, seems like DHT
 are good read only but terrible read write and this may be the case.
\end_layout

\begin_layout Standard
This, of course, is just not accepted by maidsafe and turning this problem
 into a great feature and requirement is essential.
 As noted in the section 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Alg-PKIID=SHA512Hash(RSA[pub]+Signed-[RSA[priv]])"

\end_inset

 a PKI network actually requires non changing of identities that are linked
 to a public key.
 In this case this problem described above is fantastic and were glad we
 have such an issue.
 Added to the fact even trying to alter the content of a packet of data
 that hashes to the key is an illegal instruction in maidsafe, therefor
 there's a double benefit for us.
 
\end_layout

\begin_layout Standard
The only changeable data stored on the kadmelia network as far as a maidsafe
 implementation is concerned is data deemed as, 
\emph on
Multi value one of which should be correct
\emph default
, by this it means a value should have several results and as such one of
 the result should be correct, but not necessarily all of them.
 This seems weird but is in fact very simple, basically every value will
 hash to a key or will contain multiple values (maidsafe uses signatures
 in addition to ensure safety through validation) and of each value a correct
 answer should exist in one value.
 
\end_layout

\begin_layout Example
maidsafe stores pointers to data chunks (data hashes to a key again) as
 kademlia values.
 The number of pointers is usually four (4).
 As this is a truly distributed network maidsafe expects nodes to be off
 or damaged or somehow unreachable and expects this on fairly regular terms.
 On retrieving a value, each pointer is tried to see if, not only the node
 is there, but also the node has the data (see Vaults, as data moves around
 an awful lot).
 In this way a dead or incorrect value is allowed and catered for.
 
\end_layout

\begin_layout Example
To add to this maidsafe makes use of a couple of features of the upgrades
 to kademlia explained earlier.
 This particular feature is the force-K feature to ensure close nodes are
 given a high priority, using the maximisation of near neighbor knowledge.
 A small addition to enhance this aspect is to flag all data cached throughout
 the network as cached and not a value within the k closest nodes to the
 value.
 In this manner values retrieved can be tried for validity in the knowledge
 it may be stale (only may be, very unlikely) and if so continue the search
 for the data going to the k closest nodes to ask for fresh data.
 
\end_layout

\begin_layout Example
To get to the k closest nodes we require that nodes do not return anything
 but closer nodes.
 On finding no closer being returned would indicate we have got one of the
 k closest nodes.
 This is where we alter the workings of kademlia and ask the closest node
 once more for the k closest nodes to the value were looking for.
 With the force-k addition this would likely include the k closest nodes
 (this can be further enhanced if necessary by asking all nodes returned
 the same question again and sort the answer by xor closeness).
 Assuming we have the closest nodes we can do many things but initially
 we can assume we have the valid freshest data.
 This should return pointers (from the above example) that are valid.
 
\end_layout

\begin_layout Example
Nodes with flagged cache values will check using this process they are not
 in the k closest nodes and timeout (exponentially) the cache value.
 
\end_layout

\begin_layout Subsubsection
Locks
\end_layout

\begin_layout Standard
To achieve reliability of data where multiple copies may exist and be altered
 from multiple locations is a problem that requires addressing, before changing
 data.
 Using the above scenario a node intending (and allowed to, if required)
 tries to get all the k closest nodes via an iterative search.
 On success each node is sent a lock request which it answers with (Acknowledge)
 ACK or (Negative Acknowledge) NACK.
 Each node can pass this request to its known k closest nodes.
 On receipt of k ACK's the node then alters the value (if allowed as previously
 stated).
 On receiving an altered value the holding nodes release the lock.
 Failure to receive a value update in 10 seconds should auto release the
 lock.
 
\end_layout

\begin_layout Standard
Two locks in collision (which can still happen) are compared for rank and
 the highest rank gets the lock, the lower of the two gets the NACK.
\end_layout

\begin_layout Section
Vaults
\begin_inset CommandInset label
LatexCommand label
name "sec:Vaults"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The vaults are initially a very capable, fast and efficient massively distribute
d storage mechanism, 
\emph on
not
\emph default
 a distributed filesystem as in Andrews or CFS etc.
 but a storage mechanism that can be presented on any filesystem whether
 a local system such as FAT, FAT32, NTFS, EXTx, resier etc.
 or a network file system such as NFS, Andrews, SMBFS etc.
 although debatable there would be no requirement for network file systems
 in a maidsafe network.
\end_layout

\begin_layout Standard
The vault is the storage component of the network initially, but is also
 partially responsible for signature validation, decryption and an ever
 increasing amount of services.
 Initially the vault is only concerned with 2 layers of the system.
 It is a service or daemon and controlled by either an individual client
 or several clients, these layers are as follows:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maidsafe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transport
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Transport Layer - or Layer 1 is responsible for providing the network routing,
 NAT traversal and network churn management.
 
\end_layout

\begin_layout Itemize
maidsafe (MAID) Layer - or Layer 2 is responsible for implementing most
 of what follows in this paper, including all algorithms relating to self
 healing (additional churn control), ranking, perpetual data, self encryption
 and most importantly self or anonymous authentication.
\end_layout

\begin_layout Standard
To allow fairness in the system of vaults a measurement has to be made of
 the vaults capability to store and provide access to data.
 This measurement should take into account at a minimum the vaults on line
 time, bandwidth, processing speed, free CPU availability, and drive capacity.
 This may seem like a lot to take into account and measure with any degree
 of accuracy, so a system that would allow every aspect of a vault to be
 measured had to be developed.
 This is known as 'dynamic ranking', see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Rank-Packets-(or"

\end_inset

 and is the fairest mechanism to 'measure' a vaults capability.
 
\end_layout

\begin_layout Standard
In nature this mechanism is made clear for us to see, the strength of an
 organism is how best it survives, the most effective hunters obtain the
 most nourishment, the most efficient plants grow to gather the most sunshine
 and so on.
 The lesson is the more efficient a system is the stronger and more effective
 it is.
 
\end_layout

\begin_layout Standard
Vaults are organised to mimic this philosophy in computer terms and this
 means a system that tolerates (to varying degrees) inefficiency as well
 as rewarding efficiency (as in nature).
 Vaults 'raison d'etre' is to store and allow retrieval of data, the more
 data it can store and provide the more efficient it is.
 The ability to store data should then be based in a logical manner, which
 as it turns out is a very effective process.
 
\end_layout

\begin_layout Standard
The vault process is separate from the client processes and may reside on
 another machine.
\end_layout

\begin_layout Subsection
Network 
\end_layout

\begin_layout Subsubsection
NAT traversal
\end_layout

\begin_layout Standard
Vaults require a publicly accessible UDP port for the network to function
 and a vault to provide the save/get data capability.
 This is made difficult today as most computers are behind firewalls.
 There is currently no method of firewall penetration that is guaranteed
 to work in every case.
 There are several attempts such as STUN, TURN, ICE, UPNP, PNP-NAT and many
 others but on their own there is no guaranteed method with the exception
 of (debatable) TURN where every node is connected to an external node and
 relays all traffic through it.
 This is not an acceptable situation for large data transfers though as
 the load on the TURN server would be significant.
 
\end_layout

\begin_layout Standard
There is a mechanism called UDP hole punching which shows success rates
 of around 83-92%, maidsafe utilises standard UDP hole punching using known
 accessible addresses to punch the hole through.
 The nodes that are seen as 'direct' connect are 
\end_layout

\begin_layout Enumerate
Actual direct connect
\end_layout

\begin_layout Enumerate
UPNP / PNP-NAT connected
\end_layout

\begin_layout Enumerate
Full-cone NAT 
\end_layout

\begin_layout Enumerate
Manual port forwarded connections
\end_layout

\begin_layout Standard
Each of the above can act as the hole punch go between in the maidsafe network
 giving us at least 80-90% penetration.
 The other 10% or so are regarded as not vault compatible and users would
 not be able to run a vault from that location (it would go into beacon
 mode as described 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Port-usage"

\end_inset

).
 
\end_layout

\begin_layout Subsubsection
Port us
\begin_inset CommandInset label
LatexCommand label
name "sub:Port-usage"

\end_inset

age
\end_layout

\begin_layout Standard
Vaults will default to use a random port in the range 5001-65535 (user definable
 UDP ports) in most cases the exceptions are.
 
\end_layout

\begin_layout Standard
User defined, this is where a user decides to manually port forward a router
 port to the vault (via the client RPC's).
 
\end_layout

\begin_layout Standard
The other port will be a standard fall back port 
\emph on
5483
\emph default
 and this port will broadcast the vaults presence on start-up to the local
 network (via a UDP broadcast).
 Any ports responding will do so with their KADID, this KADID which is actual
 fact the PMID will go into the vaults routing table as the internal IP:port
 of that PMID.
 The vault will only every pass this to other internally connected vaults.
 To any external request this information is ignored and the PMID external
 contact details are used.
 
\end_layout

\begin_layout Subsubsection
Network Segmentation
\end_layout

\begin_layout Standard
In the case of network failure / segmentation all vaults will periodically
 broadcast a bootstrap (FIND_NODE RPC) on this port to locate other nodes,
 when other nodes are found the internal contact details PLUS the normal
 external contact details are provided, if available.
 This allows the networks to reconfigure into smaller networks and hopefully
 find the parent network again when the network error has been sorted.
 In large catastrophes like continents going off line (possible) this allows
 maidsafe to continue to operate and it is hoped the data would be 100%
 available very quickly on such an outage.
 
\end_layout

\begin_layout Subsubsection
Listening socket
\end_layout

\begin_layout Standard
Vaults will start a listening socket for incoming messages and deal with
 them appropriately.
 The issues to be aware of here are 
\end_layout

\begin_layout Enumerate
Restarting socket/vault in event of failure (achieved by having the fallback
 socket ping this socket every 10 seconds)
\end_layout

\begin_layout Enumerate
Closing bad connections - i.e.
 attempted buffer overflows etc.
 
\end_layout

\begin_layout Enumerate
Dropping bad messages without harming the processes
\end_layout

\begin_layout Enumerate
Maintenance of a session length black list of IP:PORT combinations that
 are faults and to be dropped.
 
\emph on
This may extend later for network wide blacklists.
\end_layout

\begin_layout Subsection
Vault Control Remote Procedure Request
\end_layout

\begin_layout Standard
MAID == MAID of vault owner
\end_layout

\begin_layout Standard
PMID==PMID of vault owner
\end_layout

\begin_layout Standard
PMID1==PMID of a friend or other vault
\end_layout

\begin_layout Standard
See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Vault-Control-RPC"

\end_inset

 for a list of vault RPC's that are controlled by the owning client.
\end_layout

\begin_layout Standard
See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:vault-generalVault-General"

\end_inset

 for a list of vault RPC's that are used by other vaults and clients.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true" endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Response
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Purpose
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $Sign(PMIDkeypair)_{[MAID]}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SET_OWN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(PORT\; number)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SET_PORT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(PMID1keypair/space)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADD_ANOTHER_PMID
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(Space\: Avail)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc\; x\; Mb_{[MAID]}$
\end_inset


\begin_inset Formula $ $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FREE_SPACE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(All\; Space\: Avail)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc\; List\; dir/space_{[MAID]}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FREE_SPACE_ALL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(All\; Drives)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc\; List\; dir/space_{[MAID]}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LIST_STORES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(List\; dir/space)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SET_STORES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(DeletePMID)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETE_ALL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(DeletePMIDX)_{[MAID]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSASign(Delete)_{[MAID]}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DELETE_A_PMID
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Vault-Control-RPC"

\end_inset

 Vault Control RPC's
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Response
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Purpose
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(SAVE\; name\; size)_{[PMID1]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAVE_DATA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Give\; name)_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
chunk
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GET_DATA
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(name+RND\; DATA)_{[PMID1]})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(hash)_{[PMID]})_{PMID1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VALIDITY_CHECK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(++name)_{[PMID1]})_{rankPMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INC_RANK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(--name)_{[PMID1]})_{rankPMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DEC_RANK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(---name))_{rankPMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
REP_DEC_RANK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(addReference)_{PMID})_{referencePMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADD_REF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(delReference)_{PMID})_{referencePMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DEL_REF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(addmessage)_{allowed\; PMID})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADD_MESSAGE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(read\; all\; message)_{PMID})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(msgs))_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
READ_MESSAGES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(delmessage)_{allowed_{PMID}})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $NACK||ACK$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DEL_MESSAGE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(is\; online)_{allowed_{PMID}})_{PMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $RSAenc(Sign(IP:port))_{allowedPMID}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IS_ONLINE
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:vault-generalVault-General"

\end_inset

Vault General RPC's
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
vault Registration
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Local-Vault-Registration"

\end_inset

Local Vault Registration
\end_layout

\begin_layout Standard
This is the situation where a person is registering themselves on the system
 that actually will run their vault.
 This need not be there computer, one they have access to and is on-line
 most of the time with some available disk space.
 On successful registration the user can then log into any maidsafe client
 on any machine and access their data.
 In the case of a family situation then perhaps all the family will create
 their user id on a single machine that's always on, but then choose to
 use the client part on only their own machine.
\end_layout

\begin_layout Enumerate
A vault starts and waits on a client to connect with it to provide a PMID
 key pair.
\end_layout

\begin_deeper
\begin_layout Enumerate
Connection on 127.0.0.1 port 5483 (beacon port)
\end_layout

\end_deeper
\begin_layout Enumerate
vault ID (PMID) is generated for a vault by a client.
 
\end_layout

\begin_layout Enumerate
For a locally started vault: the client creates a PMID key pair and a PMID
 system
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
, where PMID structure is 
\begin_inset Formula $Sign(PMID[pub-key])_{[MAID]}$
\end_inset


\end_layout

\begin_layout Enumerate
This PMID is saved to the network 
\begin_inset Formula $netputV_{PMID-packet}$
\end_inset


\end_layout

\begin_layout Enumerate
The vault will then be contacted via an RPC message (RPC SET_OWN) by the
 local client.
\end_layout

\begin_layout Enumerate
The vault takes the keys (and possibly a start port (RPC SET_PORT) for situation
s where users will port forward rather than have maidsafe hole punch or
 otherwise get through a firewall) and creates a config file which it will
 read on startup.
 The config file contains at a minimum an optional PORT and required PMID
 private and PMID public key, MAID public key, signature of PMID pub key
 with MAID private key and node ID (which is hash of PMID_pub_key signed
 by MAID).
\end_layout

\begin_layout Enumerate
The vault then starts it's main port and goes through the normal bootstrap
 process.
\end_layout

\begin_layout Subsubsection
Remote Vault Registration
\end_layout

\begin_layout Standard
TBD
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
For a vault started as purchased proxy (better thought of as purchasable
 proxy): vault broadcasts available space to maidsafe.net: New packet 
\emph on
PPMID
\emph default
 (Purchasable Proxy maidsafe ID) .
 This is achieved by encrypting the MPID (keys) and space available and
 sending this to a maidsafe buffer packet, which is basically a public ID
 (MPID) of maidsafe the word (ie H(maidsafe+BUFFER)).
\end_layout

\begin_layout Enumerate
maidsafe has a process of receiving these packets to identify the PMID's
 it can sell.
 maidsafe may also split these vaults into smaller chunks (MPIDS) to sell
 these in a granular fashion.
\end_layout

\begin_layout Enumerate
The packet is decrypted the MPID exposed with the private key for it.
\end_layout

\begin_layout Enumerate
For some PD client requesting to purchase a remote vault, a payment is made
 via a payment mechanism such as Google checkout or similar.
 The user receives an PMID and private key for the MPID with the appropriate
 space available to allow control of it.
 
\end_layout

\begin_layout Enumerate
The client searches for the MPID identifier on the network and having the
 private key he can delete the existing identifier (PMID signed pub key)
 with his own newly created public key pair.
\end_layout

\begin_layout Enumerate
The client now has control of the remote pd vault and can force replacement
 of the vaults private key and sign the MPID with his own MAID to show who
 controls the vault.
 This is possible as maidsafe makes the PMID private key available in (7).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Vault Startup
\end_layout

\begin_layout Enumerate
Vaults starts up, demonizes and reads its configuration file, or waits on
 ownership in registration mode, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Local-Vault-Registration"

\end_inset

.
\end_layout

\begin_layout Enumerate
From the file it takes the hash of the signed public PMID key, this is the
 vault ID (==PMID) 
\end_layout

\begin_layout Enumerate
The vault now carries out a network bootstrap to determine its connectivity
 status (behind firewall etc..), this is done from a list of potential network
 bootstrap nodes who are directly connected
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this scenario directly connected means has a publicly accessible IP/PORT
 that's directly accessible from any node without requiring rendezvous or
 similar.
\end_layout

\end_inset

' and can act as rendezvous nodes if need be.
\end_layout

\begin_layout Enumerate
The vault now carries out a kademlia bootstrap (FIND_NODE==PMID), this is
 done from a cache of previously known kademlia nodes (sorted by rank -
 highest first)
\end_layout

\begin_layout Enumerate
The vault then does a check on each chunk to determine what chunks are still
 under it's control (i.e.
 it is in the reference holders value for the chunk).
\end_layout

\begin_layout Enumerate
The vault then moves the lost chunks to it's cache directory
\end_layout

\begin_layout Subsection
Chunk References
\begin_inset CommandInset label
LatexCommand label
name "sub:Chunk-References"

\end_inset


\end_layout

\begin_layout Standard
As a vault stores a chunk it updates the chunk reference packet with a message
 signed by it's PMID.
 This packet takes the form 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Chunk Name (Key)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PMID1-NAME_{[PMID]}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $PMID2-NAME_{[PMID]}$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
....
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The key holder is the k closest nodes to the key as standard in Kadmelia
 networks.
 It has to know this is a chunk reference packet and follows these rules.
\end_layout

\begin_layout Enumerate
Allow deletion of a value by the signing authority of the value (in this
 case the value is a PMID (512 bit hash)) and the signature is the PMID
 signed by the PMID private key.
 The deletion instruction would have to be signed by the PMID private key.
 This can be thought of as self deletion, i.e.
 it is the PMID deleting itself from the reference.
\end_layout

\begin_layout Enumerate
Allow deletion of a value on lost chunk - by the request of any of the other
 chunk holders signed by their PMID.
 In this case the holder will confirm with the 'to be deleted' PMID that
 the vault has in fact lost the chunk (or stopped storing it), this is done
 via a RPC.
 If the deletion request is valid the reference is removed and the existing
 chunk holder messaged (to their buffer packet - or direct) that there is
 a lost chunk
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It should be noted here, this is a case where a signed data bit can be deleted,
 by someone who is not the signatory.
 This is only allowed by reference holders and confirmed by every reference
 holder.
 i.e.
 when an update is done here then the reference holder republishes the value
 to the K closest nodes immediately.
 This republish MUST contain the signed deletion instruction in the case
 of point 1 or it must contain the deletion request in point 2, in this
 case each holder confirms again the deletion is in fact true, otherwise
 republish again.
 Republish does not mean any node updates the rank this is only done once
 by the original reference holder.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Enumerate
For both 1 & 2 above the deleted PMID rank packet (see
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Rank-Packets-(or"

\end_inset

) is decremented by a value of 1.
\end_layout

\begin_layout Enumerate
In the case of a PMID being added to this reference then the PMID add reference
 message is stored in the cache directory.
\end_layout

\begin_layout Subsection
Rank 
\begin_inset CommandInset label
LatexCommand label
name "sub:Rank-Packets-(or"

\end_inset

 (or fairness meter !)
\end_layout

\begin_layout Standard
As previously discussed for this system to operate effectively the vaults
 have to be able to provide a mechanism that allows the good to grow and
 the weak to fail and all the options in between.
 This is accomplished using special system packets called rank packets.
 These rely on a the ability to delete single signed values from a chunk
 containing a list of values.
 This particular chunk is called a rank chunk.
\end_layout

\begin_layout Standard
So a rank chunk is H(MPID + "RANK") (the actual word rank).
 
\end_layout

\begin_layout Standard
This packet is held as a Kademlia key value in the K closest nodes as standard
 in kademlia.
 Again as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Chunk-References"

\end_inset

 the node has to know this is a rank packet and follow some rules regarding
 it.
\end_layout

\begin_layout Subsubsection
Rank Decrement
\end_layout

\begin_layout Enumerate
On receipt of an decrement rank message - the signature is checked , confirm
 that this is a signature of the reference chunk holder, also the remove
 request notice is passed as a part of this signed message, the signature
 of this remove notice is also checked.
 
\end_layout

\begin_layout Enumerate
The rank is decremented and the validation packet described above is passed
 to the K closest nodes to do likewise.
\end_layout

\begin_layout Enumerate
Any note to decrement a rank is checked by all nodes, in case of disagreement
 this is a majority rule situation where the majority will likely be the
 actual rank sorted due to churn effects of the network.
\end_layout

\begin_layout Subsubsection
Rank Increment
\end_layout

\begin_layout Standard
In this case the actual PMID to be incremented is responsible for acquiring
 the increment notice.
 This is done using the following process.
\end_layout

\begin_layout Enumerate
Store request used to store the chunk initially is wrapped in the increment
 request sent to the reference holder by the PMID.
 The reference holder stores this request in his cache folder.
\end_layout

\begin_layout Enumerate
The RANK holder contacts the reference holder to confirm this addition to
 the reference packet took place.
 This is requested by the PMID storing the chunk.
\end_layout

\begin_layout Enumerate
The reference holder checks his cache dir for the relevant add reference
 PMID to the value, confirms this back to the rank holder.
 
\end_layout

\begin_layout Enumerate
The reference holder then republishes the new chunk reference with the k
 closest nodes and the copy of the increment request.
\end_layout

\begin_layout Enumerate
The reference holder deletes the relevant add reference file(to stop multiple
 adds).
\end_layout

\begin_layout Enumerate
The RANK holder now republishes the updated rank with the copy of the increment
 request
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In this packet every time a chunk is stored by at least 3 (yes 4 copies
 of every chunk of data) partners, the partners all sign a chunk X message
 i.e.
 
\end_layout

\begin_layout Itemize
ABC stored by me (otherwise no ABC stored notifications allowed - to stop
 attack) 
\end_layout

\begin_layout Itemize
ABC stored / signed by node 123 
\end_layout

\begin_layout Itemize
ABC stored / signed by node 234 
\end_layout

\begin_layout Itemize
ABC stored / signed by node 132 
\end_layout

\begin_layout Plain Layout
would indicate chunk ABC has been stored by yourself and nodes 123, 234,
 132.
 This is a FIFO list - meaning all new checks are at the top of the list
 - older checks at bottom - so when a check is performed the AB stored info
 is rewritten to top of list and the copy removed from bottom.
 
\end_layout

\begin_layout Plain Layout
the number of chunk's marked as stored is your rank - it's that simple,
 but as ever a couple more bits required (cause chunks will get lost, corrupted
 etc.).
 Here's the process
\end_layout

\begin_layout Itemize
Lost chunk - Partners delete their ABC stored and replace with ABC lost
 
\end_layout

\begin_layout Itemize
Corrupt chunk - Partners delete their ABC stored and replace with ABC corrupt
 
\end_layout

\begin_layout Plain Layout
NB: This is possible due to our golden rule - only the signatory can delete
 a signed bit of data (or value).
 So the rank of the node is calculated by 
\end_layout

\begin_layout Enumerate
Add up all stored chunks 
\end_layout

\begin_layout Enumerate
Subtract lost chunks 
\end_layout

\begin_layout Plain Layout
Also in the special case of corrupt chunk at bottom of list, no rank is
 available (no store allowed).
 In this case the client has to wait on validity checks of other chunks
 which will gradually move this corrupt data to bottom of the list (at the
 bottom it's considered safe again).
 When the data gets to the bottom of the list the holder(s) request the
 partners that were involved delete the reference, if they cannot be contacted
 the reference is deleted by the holder in agreement with partner holders
 (NB - a violation of our only signatory can delete rule).
 In any case corrupt at bottom of the list will not affect nodes rank -
 it's considered ok.
 
\end_layout

\begin_layout Plain Layout
On it's [corrupt chunk notice] way to the bottom of the list the rank of
 the machine is - All stored chunks (after the corrupt one - ignoring all
 others before it) and again subtract all lost chunks.
\end_layout

\begin_layout Plain Layout
So corrupting data will affect a machine - but quickly (depending on validity
 checks) it can be retrieved.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Find Rank
\end_layout

\begin_layout Standard
How do we store / find this rank etc.
\end_layout

\begin_layout Standard
The rank is part of the contact tuple for each PMID on the network and transmitt
ed and saved into routing tables.
 The update rank can be obtained at any time by checking the rank packet.
 This rank should be returned with every FIND_NODE RPC.
 A FIND_RANK RPC will allow the kademlia network to be queried for all nodes
 close to the RANK packet and the average of the returned values is considered
 that nodes rank.
 This RPC will be performed prior to a STORE_DATA RPC to ensure the rank
 is correct and up to date, when required.
\end_layout

\begin_layout Standard
The client can decide to carry out a rank check (get the H(node ID + "rank"))
 if less than alpha returns contain the same rank for that node.
\end_layout

\begin_layout Subsection
Save Chunk Location
\end_layout

\begin_layout Standard
To store a bit of data - we want to find nodes to store this on - so what
 nodes do we want.
 well we need to know the RTT for nodes in our routing tables and we calculate
 the locations based on rank / RTT e.g.
 1: our rank is 1123 2: We search for nodes with a rank just short of this
 or equal (from our routing table) 3: We get the distribution of these nodes
 by call - closest - furthest - then the two at ~33% and ~67%.
 4: do a swap chunk 
\end_layout

\begin_layout Subsection
Swap Chunk 
\end_layout

\begin_layout Standard
Swap Chunk example
\end_layout

\begin_layout Standard
Swap chunks are the method used for storing data, you will already have
 candidates with good Geo location and rank.
 The offer to store a chunk of the same size is made to them (they should
 be happy your rank is probably better than theirs).
 Recipient 1: checks your rank 2: If you have any lost chunk references
 - they will request you contact the holder of a lost chunk and get another
 copy and have them sign a stored receipt in your rank packet.
 3: They agree to the swap.
 The chunk they swap will be of a same or less size - but their choice of
 which chunk is decided by a few factors a: size (obviously) b: Length of
 time they have held the chunk (use oldest first) / OR a chunk which shows
 your RTT is further away than their partners for this chunk.
 
\end_layout

\begin_layout Standard
You 1: On swap agreement - you send your chunk the first (closest partner)
 and the nodes to store on.
 2: Each node in turn replies with a stored OK - you remove from your queue
 (this can be carried out much faster by relaying all data from start through
 partners to last partner - single transmission).
 Each node keeps a copy of the data swapped - i.e.
 swapped chunk ABC for DEF with node 243 etc.
 (see cache lost chunks) See later about how
\end_layout

\begin_layout Subsection
Cache Chunk 
\end_layout

\begin_layout Standard
When searching for a chunk (akin to find value in kademlia) you tell the
 last node that did not have the chunk to take a copy of this data.
 The last node gets the data and consequent find value will return this
 chunk to the searcher.
\end_layout

\begin_layout Standard
Cache times - or how long do we store a cache chunk ?
\end_layout

\begin_layout Standard
Option 1: As in kademlia we store the cache chunk for a time which is inversely
 proportional to the xor distance from the original.
\end_layout

\begin_layout Standard
Option 2: Store in a FIFO directory - so don't delete till FIFO is full.
\end_layout

\begin_layout Standard
DISCUSS !!
\end_layout

\begin_layout Subsection
Cache Lost Chunk 
\end_layout

\begin_layout Standard
In the special case of lost chunks we need to make copies - and how to do
 this fairly has been a point of internal debate for me anyway.
 It would appear there may be a flaw in the design as a hacker may just
 request all his chunks are lost copies, thereby bypassing any payment.
\end_layout

\begin_layout Standard
So there's a couple of rules to stop that and enhance the system 1: Chunk
 lost store request must be co signed by original storage partners.
 2: Cache lost chunks stored in a separate locations from normal cache (only
 to differentiate) but follows same rules about giving the data.
 3: Cache chunk is stored along with the ID of who stored it.
 4: A validity check on these chunks is requested to force the partners
 to again check the node that lost the chunk - if all ok - this chunk is
 deleted (or moved to normal cache dir and follow same rules as a normal
 cache chunk) 5: If there is no chance to have this taken back the cache
 chunk holder is deemed to now be in control of this chunk and the partners
 sign an receipt for having stored a chunk (DISCUSS) 6: In the case of 5
 the originator will have his swap chunk swapped back for no charge by the
 partners (he has not honored his deal by losing this chunk) - so when he
 is next on line he can take the chunk back or lose it ! - If the chunk
 has more people looking at it (i.e.
 buffer packet shows more people looking at it) then the originator is penalized
 with a lost chunk notice on his rank packet.
\end_layout

\begin_layout Subsection
Validity Check
\end_layout

\begin_layout Standard
The validity check is as previous design except the timing of such.
 Validity checks can be initialized in several ways
\end_layout

\begin_layout Enumerate
A chunk holder is asked for a chunk (original chunk holder only).
 [done after chunk passed] 
\end_layout

\begin_layout Enumerate
Any chunk swapped will mean the partners will do a validity check to ensure
 the new location is ok.
 
\end_layout

\begin_layout Enumerate
On startup - any chunk noted as lost in your rank packet - should initiate
 a check on that chunk.
 
\end_layout

\begin_layout Enumerate
At any time a corrupted chunk in the rank packet should initiate a check
 on all chunks you have (otherwise you will find it hard to save data -
 or the client attached the the vault will).
 This will make the corrupted one go to bottom of the list faster.
 
\end_layout

\begin_layout Standard
Each of the above is done in conjunction with a validity check for the chunk
 with longest time between a validity check.
 ! Any validity check for any chunk will mean you always check the longest
 unchecked chunk.
\end_layout

\begin_layout Subsubsection
Implementation
\end_layout

\begin_layout Standard
This checking process is between partner nodes who all share a common chunk.
 i.e.
 a chunk copied 4 times will have 4 validity checking nodes.
 To allow the network to check the data without transmitting the actual
 data another method is described below.
 It should be noted that ALL data chunks ID is a hash of the content, therefore
 there is another check available for end user client node to validate the
 data they receive.
 The partner node validity check is described below:
\end_layout

\begin_layout Enumerate
Cn -> 
\begin_inset Formula $r=rnd(chars),\: res\equiv H(c1+r)$
\end_inset


\end_layout

\begin_layout Enumerate
Cn takes chunk name (C1) and r and passes to S2 and S3 and requests they
 perform the same operation and pass the answer (result) back
\end_layout

\begin_layout Enumerate
If any node has false answer which differ from the other 2 then it has dirty
 data
\end_layout

\begin_layout Enumerate
The other nodes raise alerts (signed) and copy a new chunk to a new location
\end_layout

\begin_layout Enumerate
All other nodes storing data on Sn are now alerted to check
\end_layout

\begin_layout Enumerate
Each node will publish the chunk reference
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Chunk-References"

\end_inset

 if it has been lost for any reason.
\end_layout

\begin_layout Section
Clients
\end_layout

\begin_layout Standard
The maidsafe network can be considered as a three layer stack design as
 follows:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Filesystem/ GUI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maidsafe
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transport
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The layers can be thought of as:
\end_layout

\begin_layout Itemize
Network Layer - or Layer 1 is responsible for providing the network access.
 
\end_layout

\begin_layout Itemize
MAID Layer - or Layer 2 is the storage area as far as a client can tell.
\end_layout

\begin_layout Itemize
FileSystem Layer - or Layer 3 is the area of the system responsible for
 presenting the user with a filesystem from which to work with data.
 Initially this will be a FUSE implementation (Filesystem In User Space).
 For embedded systems where FUSE type is not available the file interface
 may be controlled via a traditional explorer type windows in the application
 itself rather than as another filesystem accessible from any native application.
\end_layout

\begin_layout Subsection
Self Authentication 
\end_layout

\begin_layout Standard
A user is authorised on the the network with 3 unique pieces of information.
 A username (U), a pin number (P), and a password (W).
 We use a method of hashing called Secure Hash Algorithm (SHA) in this case.
 SHA produces a code for given data, any small change in the data produces
 significantly different code.
 It is non reversible and consistent (given consistent data).
 
\end_layout

\begin_layout Subsection
Create a User Identity
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $H(H(U)+H(P))\equiv\mathcal{MID}$
\end_inset

 
\begin_inset Formula $H(H(U)+H(P)+1)\equiv\mathcal{SMID}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netgetV(\mathcal{MID})\equiv NIL$
\end_inset

 
\begin_inset Formula $\&\&\; netgetV(\mathcal{SMID})\equiv NIL$
\end_inset

 (to ensure uniqueness)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
Create a MAID packet as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $d\equiv rnd(),\; R\equiv AESenc{\scriptscriptstyle _{PBKDF2(U,P)}{\displaystyle {\textstyle {\textstyle (d)}}}}$
\end_inset


\end_layout

\begin_layout Enumerate
Create
\emph on
 ANMID
\emph default
 as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle {\textstyle sign}_{(k)_{ANMID}}{\displaystyle (R)\equiv R{\scriptstyle s}}}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD{\scriptstyle _{[MID]}{\scriptscriptstyle {\textstyle (}{\textstyle R{\scriptstyle s{\textstyle )}}}}}$
\end_inset

 [
\emph on
MID
\emph default
 packet]
\end_layout

\begin_layout Enumerate
Create
\emph on
 ANSMID
\emph default
 as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle {\textstyle sign}_{(k)_{ANSMID}}{\displaystyle (R)\equiv R{\scriptstyle s}}}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD{\scriptstyle _{[SMID]}{\scriptscriptstyle {\textstyle (}{\textstyle Q_{s}{\textstyle )}}}}$
\end_inset

 [
\emph on
SMID
\emph default
 packet]
\end_layout

\begin_layout Enumerate
Create
\emph on
 ANMID
\emph default
 as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula ${\scriptstyle }$
\end_inset


\begin_inset Formula $RSAsign_{(k)_{[ANMIAD]}}{\scriptstyle }(p)\equiv x$
\end_inset

 (sign public key with private key)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD_{[\mathcal{MAID}]}{\scriptscriptstyle }(x)$
\end_inset

 [
\emph on
MAID
\emph default
 packet] - used later created on registration only.
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $n\equiv H(H(U)+H(P)+H(d)$
\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $TMID\equiv AESenc_{[PKDBF2(W,rid)]}(DM\: of\: DA)$
\end_inset


\end_layout

\begin_layout Enumerate
Create ANTMID as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $\mathcal{TMID}{\scriptstyle s}\equiv RSA{\textstyle sign_{(k)_{\mathcal{[ANTMID]}]}}{\scriptscriptstyle }}(\mathcal{TMID})$
\end_inset

 (signed by 
\emph on
MAID3ID
\emph default
 to allow delete and separate from 
\emph on
MAID
\emph default
)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD(\mathcal{TMID}_{s})$
\end_inset

 [
\emph on
TMID
\emph default
 PACKET]
\end_layout

\begin_layout Subsection
Login to System
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $H(H(U)+H(P))\equiv\mathcal{MID}$
\end_inset

 
\begin_inset Formula $H(H(U)+H(P)+1)\equiv\mathcal{SMID}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $netgetD\mathcal{(MID})\equiv R_{s}$
\end_inset

 on fail 
\begin_inset Formula $netgetD\mathcal{(SMID})\equiv R_{s}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AESdec{\scriptstyle _{_{PBKDF2(U,P)}}{\scriptscriptstyle }}(R)\equiv d$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $n\equiv H(H(U)+H(P)+H(d))$
\end_inset

(ensure unique)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $netgetD(n)\equiv\mathcal{TMID}_{s}{\scriptstyle }$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $AESdec{\scriptscriptstyle _{(PDBKDF2(W,rid))}{\scriptstyle }}(\mathcal{TMID}_{s})\equiv\mathcal{TMID}$
\end_inset

 Thus we have the Data Atlas
\end_layout

\begin_layout Subsection
Log Out (or Update) 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $d\equiv rnd(),\; R\equiv AES{\textstyle {\textstyle enc}}{\scriptscriptstyle _{PBKDF2(U,P)}{\displaystyle {\textstyle {\textstyle (d)}}}}$
\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle {\textstyle sign_{(k)_{[ANsMID]}}}{\displaystyle (R)\equiv R{\scriptstyle s}}}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD_{[\mathcal{SMID}]}{\scriptstyle {\scriptscriptstyle {\textstyle (}{\textstyle R{\scriptstyle s{\textstyle )}}}}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $n\equiv H(H(U)+H(P)+H(d))$
\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $\mathcal{TMID}$
\end_inset


\begin_inset Formula $\equiv AESenc_{[PDBKDF2(w,rid)]}{\textstyle {\scriptstyle {\scriptscriptstyle {\textstyle (\mathcal{MAID}}}{\textstyle +k}}}+DA)$
\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $\mathcal{TMID}_{s}{\scriptstyle }\equiv RSA{\scriptscriptstyle {\textstyle sign_{(k)_{[ANTMID]}}}}(\mathcal{TMID})$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netput(\mathcal{TMID}_{s}{\scriptstyle })$
\end_inset


\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle {\textstyle sign_{(k)_{[ANMID]}}}{\displaystyle (R)\equiv R{\scriptstyle s}}}$
\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netputD_{[\mathcal{MID}]}{\scriptstyle {\scriptscriptstyle {\textstyle (}{\textstyle R{\scriptstyle s{\textstyle )}}}}}$
\end_inset


\end_layout

\begin_layout Subsection
Self Encryption
\begin_inset CommandInset label
LatexCommand label
name "sub:Self-encryption"

\end_inset


\end_layout

\begin_layout Notation
\begin_inset Formula $chunk{\scriptscriptstyle n}(x)\equiv\overrightarrow{x}$
\end_inset

n-chunking operation (with padding) 
\begin_inset Formula $x{\scriptscriptstyle 1}+x{\scriptscriptstyle 2}+\ldots\equiv pad{\scriptscriptstyle n}(x),\left|X{\scriptscriptstyle i}\equiv n,\right|$
\end_inset


\end_layout

\begin_layout Notation
\begin_inset Formula $concat(x_{1},x_{2}\ldots)\equiv\vec{x}$
\end_inset

 chunking operation
\end_layout

\begin_layout Notation
\begin_inset Formula $rot_{n}(\overrightarrow{x})\equiv\overrightarrow{\tilde{x}}$
\end_inset

rotating operation (shift left cyclic (put last chunk in first position))
\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $f{\scriptscriptstyle c}\equiv file\: content,\: f{\scriptscriptstyle m}\equiv file\: metadata,\: hm\equiv H(f{\scriptscriptstyle m})$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $\overrightarrow{c}\equiv chunk{\scriptscriptstyle {\scriptstyle {\scriptscriptstyle n}}{\textstyle (f{\scriptscriptstyle c})\equiv c{\scriptscriptstyle 1}c{\scriptscriptstyle 2}\ldots c{\scriptscriptstyle m-1}c_{m}}}$
\end_inset

 where r is fixed ref chunk same size as c with size n
\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $\vec{h}\equiv H(\vec{c)}=H(c{\scriptscriptstyle 1}),H(c{\scriptscriptstyle 2})\ldots H(c{\scriptscriptstyle m-1})H(cm),\: rot(\vec{h})\equiv\vec{q,\: hf\equiv H(concat(\vec{q))}}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $r=hf+hf\, till\, r=n$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $\vec{e}\equiv(c{\scriptscriptstyle 1}\bigoplus c{\scriptscriptstyle 2})(c{\scriptscriptstyle 2}\bigoplus c{\scriptscriptstyle 3})\ldots(r\bigoplus c{\scriptscriptstyle 1})\equiv\overrightarrow{c}\bigoplus rot(\overrightarrow{c})$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $\overrightarrow{f}\equiv AESenc_{{\scriptscriptstyle q1}}(e{\scriptscriptstyle 1})AESenc{\scriptscriptstyle _{q2}}(e{\scriptscriptstyle 2})\ldots AESenc_{{\scriptscriptstyle qm}}(e{\scriptscriptstyle m})\equiv AESenc{\scriptscriptstyle \overrightarrow{q}}(\overrightarrow{c}\bigotimes\overrightarrow{\widetilde{c}})\equiv AESenc{\scriptscriptstyle rot(\overrightarrow{h}}(chunk{\scriptscriptstyle n}(fc)\bigoplus\widetilde{chunk}{\scriptscriptstyle n}(fc))$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
\begin_inset Formula $\overrightarrow{f}\equiv selfenc{\scriptscriptstyle n}(fc)\equiv AESenc{\scriptscriptstyle rot\overrightarrow{(q)}{\textstyle (chunk{\scriptscriptstyle n}(fc)\bigoplus\widetilde{chunk}{\scriptscriptstyle n}(fc)}}$
\end_inset


\end_layout

\begin_layout Subsection
Data Maps 
\begin_inset CommandInset label
LatexCommand label
name "sub:Data-maps"

\end_inset


\end_layout

\begin_layout Standard
For a particular file
\end_layout

\begin_layout Standard
\begin_inset Formula $\hat{D_{hf}\equiv\vec{h}X\vec{f}\equiv\left\{ h_{1}:f_{1,}h_{2}:f_{2},\ldots\right\} }$
\end_inset


\end_layout

\begin_layout Standard
Metadata data maps (may be multiple)
\end_layout

\begin_layout Standard
\align left
\begin_inset Formula $\hat{M}_{fm}^{^{1}}\equiv\left\{ 1:hf\right\} +\vec{hm^{1}}\times\vec{\: fm^{1}\equiv\left\{ 1:hf,hm_{1}^{1}:fm_{1}^{1},\: hm_{2}^{1}:fm_{2}^{1},\ldots\right\} }$
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset Formula $\hat{M}_{fm}^{p}\equiv\left\{ 1:hf\right\} +\vec{hm^{p}}\times\vec{\: fm^{p}\equiv\left\{ 1:hf,hm_{1}^{p}:fm_{1}^{p},\: hm_{2}^{p}:fm_{2}^{p},\ldots\right\} }$
\end_inset


\end_layout

\begin_layout Standard
Then
\end_layout

\begin_layout Standard
\begin_inset Formula $D_{n}\hat{DF}\equiv\hat{D_{hf}}+\sum_{i=1}^{p}\hat{M_{fm}^{i}}\equiv\left\{ 1:hf,\: hm_{1}^{1}:fm_{1}^{1},hm_{2}^{1}:fm_{2}^{1},\ldots hm_{1}^{p}:fm_{1}^{p},\ldots\right\} $
\end_inset

This is the data map for this file
\end_layout

\begin_layout Standard
serialise data map into scalar (string) 
\begin_inset Formula $concat(\vec{DF})\equiv DF$
\end_inset


\end_layout

\begin_layout Subsection
Data Atlas
\end_layout

\begin_layout Standard
Construct the data map for each file in the system in this way and create
 the serialised Data Atlas
\end_layout

\begin_layout Standard
\begin_inset Formula $DF\equiv ser(\sum_{files}\hat{DF^{i})}$
\end_inset


\end_layout

\begin_layout Standard
Add data structure (key pairs etc.
 for all 
\emph on
ID
\emph default
's (
\emph on
MAID, MID, PMID
\emph default
 etc)
\end_layout

\begin_layout Standard
\begin_inset Formula $\hat{P}\equiv\left\{ ID_{1}:k_{1}:p_{1}:\ldots ID_{n}:k_{n}:p_{n}\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\hat{DF}\equiv DF+ser(\hat{P})$
\end_inset


\end_layout

\begin_layout Standard
Now Data Atlas is formed
\end_layout

\begin_layout Standard
\begin_inset Formula $\hat{DA}\equiv\vec{h_{DA}\times selfenc(\hat{DF}),\:\vec{h_{DA}\equiv chunk_{n}(\hat{DF})}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $DA\equiv ser(\hat{DA)}$
\end_inset


\end_layout

\begin_layout Standard
The Data Map (i.e.
 
\begin_inset Formula $DM=selfenc(DA)$
\end_inset

) of the Data Atlas is what is stored to the TMID and encrypted with the
 users password (W).
 Data Atlas's are represented to the user as a file system with the file
 name and path containing the file hash which maps to the Data Atlas to
 retrieve the file content.
\end_layout

\begin_layout Subsection
Public ID MPID
\begin_inset CommandInset label
LatexCommand label
name "sub:Public-ID-MPID"

\end_inset


\end_layout

\begin_layout Standard
This is a different packet from others as its name must be the hash of the
 users chosen public name.
 Unlike other packets MPID public Id's should be stored with any node that
 communicates with it.
 Only allowing delete from these nodes with a revocation certificate [LATER]
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $t\equiv userinput,\:\mathcal{MPID}\equiv H(t),\: netget(\mathcal{MPID})\equiv NIL$
\end_inset

 (to ensure uniqueness)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $netget(\mathcal{MPID}+BUFFER)\equiv NIL$
\end_inset

 (to ensure uniqueness of the buffer packet for sending messages later)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle {\scriptscriptstyle {\textstyle genkeypair}}}(MPID)\equiv(k,p)$
\end_inset


\end_layout

\begin_layout Enumerate
Create [ANMPID] from section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

 
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $RSA{\scriptstyle sign_{(k)_{[ANMPID]}}{\displaystyle (p)\equiv p_{s}}}$
\end_inset

 (signed to ensure only owner can delete)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netput_{[\mathcal{MPID}]}{\scriptstyle {\scriptscriptstyle {\textstyle (}{\textstyle p{\scriptstyle _{s})}}}}$
\end_inset

 (
\emph on
MPID
\emph default
 packet)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula $netput_{[\mathcal{MPIDBUFFER}]}{\scriptstyle {\scriptscriptstyle {\textstyle (}{\textstyle )}}}$
\end_inset

 (
\emph on
MPIDBUFFER
\emph default
 packet)
\end_layout

\begin_layout Enumerate
\paragraph_spacing onehalf
\align left
\begin_inset Formula ${\scriptstyle }$
\end_inset

Store k and 
\emph on
MPID
\emph default
 in the private key chain 
\begin_inset Formula $\hat{P}$
\end_inset

 of the DA for later use
\end_layout

\begin_layout Standard
The MPID buffer packet may contain a list of ID's allowed to post messages
 there.
 This is described in the messenger section.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Messenger-system-(version"

\end_inset


\end_layout

\begin_layout Subsection
Store Data on Network
\begin_inset CommandInset label
LatexCommand label
name "sub:Store-Data-on"

\end_inset


\end_layout

\begin_layout Standard
S(1-3) = Storage node : Cn = client node (vault - identified by a PMID).
 We should be aware as a client saves chunks these are passed to his or
 her vault to process the following: (also see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Chunk-lifetimes-and"

\end_inset

)
\end_layout

\begin_layout Enumerate
Cn -> locates S1, S2, S3 to store a chunk c1, this requires finding out
 the correct rank as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ranking"

\end_inset

 and also the correct timezones or whatever system is used to sub divide
 the network.
\end_layout

\begin_layout Enumerate
S1 reply's OK you need to store a chunk (c2) from me to.
 This chunk is of the same size.
\end_layout

\begin_layout Enumerate
S1 gives the Sa2 and Sa3 nodes relating to C2 Cn as the replacement for
 him in the checking process.
 S1 updates the DHT by replacing values for key C2 to include Sa2 Sa3 and
 Cn being the new partners of this chunk.
 
\end_layout

\begin_layout Enumerate
Cn Sa2 and Sa3 are now all sharing C2.
\end_layout

\begin_layout Enumerate
S1 accepts Cn (C1) chunk.
\end_layout

\begin_layout Enumerate
Cn passes C1 to S2 and S3 giving them signed statements from Sa2 and ` 
\begin_inset Formula $RSAsign_{(k)_{[PMID(Sa3)]}}("Cn\: has\: stored\: C2\: for\: payment\: of\: store\: C1")$
\end_inset

 [confirms Sa2 and Sa3 are happy with the swap]
\end_layout

\begin_layout Enumerate
S2 and S3 confirm C2 saved and OK, by checking DHT for C2 Values.
\end_layout

\begin_layout Enumerate
S2 and S3 accept the chunk copy and begin the checking process.
\end_layout

\begin_layout Enumerate
If Cn fails tests within 72 hours (this will be calculated based on number
 of chunks and network tuning) then the contract is nullified and S1 takes
 back the C2 checking process with S2 and S3.
 Cn then has to renegotiate a new location on another rank for C1.
 TODO add rank
\end_layout

\begin_layout Subsection
Client Node Churn Resolution
\end_layout

\begin_layout Standard
As vaults from rank 0 to X are expected to be on line for a determinable
 percentage of time (or else they are demoted / promoted) then their effect
 on churn is somewhat determinable.
 However, client nodes are not, and so they can have a detrimental effect
 on churn.
 To alleviate this, maidsafe issues client nodes with network addresses
 which have pre-determinable information.
 
\end_layout

\begin_layout Standard
As maidsafe alters Kademlia to use a 512 bit number rather than a SHA-1
 160 bit number as a network address, there is some leeway to play with.
 The solution is 
\end_layout

\begin_layout Itemize
All client node's addresses comprise an initial (512-160) 352 bits which
 are all 
\begin_inset Quotes eld
\end_inset

-
\begin_inset Quotes erd
\end_inset

s (hyphens)
\end_layout

\begin_layout Itemize
All client node's last 160 bits of address will be a standard SHA-1 hash
 160 bits long.
 
\end_layout

\begin_layout Standard
To implement this we have is_unique calls in the system to ensure we do
 not have collisions of data on the network, including creating ID's with
 key pairs etc.
 (at the system level).
 To ensure we never try and store a 
\begin_inset Quotes eld
\end_inset

- - - -
\begin_inset Quotes erd
\end_inset

 (352 bits long) address part we add this pattern to the is_unique() check.
 If this fails we assume a collision and create a new key pair etc.
 to hash for an ID (as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Create-an-ID"

\end_inset

) or alter the number of chunks in a data file.
 As this is a system fundamental then we should never have any client storing
 key value pairs of significance and their churn is much less damaging to
 the system.
\end_layout

\begin_layout Subsection
Get Data from Network
\end_layout

\begin_layout Standard
To retrieve network data it's a method of search for chunk and retrieve.
 It can be broken into small pieces as follows:
\end_layout

\begin_layout Enumerate
Get chunk name from DA (or in case of MID from H(U+P))
\end_layout

\begin_layout Enumerate
Find nearest node to this name.
\end_layout

\begin_layout Enumerate
Retrieve the value for the key of the name, this will provide at least 3
 locations of duplicate chunks.
\end_layout

\begin_layout Enumerate
Ping each location.
\end_layout

\begin_layout Enumerate
As soon as first answer then this is fastest node, request the download
 from this location.
\end_layout

\begin_layout Subsubsection
Delete Data from Network
\end_layout

\begin_layout Standard
The act of deleting data is again relatively although some caveats are in
 place.
 Here we distinguish between data chunks and system chunks.
 
\end_layout

\begin_layout Standard
Data chunks are chunks on the network where the name (which is also the
 key in the DHT key value pair) is equivalent to the hash of the chunk content.
 this provides a safety check for chunk validity.
 System chunks on the other hand may not always meet this criteria, although
 all system chunks are signed by a PKI private key.
 
\end_layout

\begin_layout Standard
The process is as follows.
\end_layout

\begin_layout Enumerate
vault gets a signed request to delete a chunk.
\end_layout

\begin_layout Enumerate
vault checks this chunk by attempting to extract a signature.
\end_layout

\begin_layout Enumerate
If the signature matches the requesting signature the chunk is deleted.
 
\end_layout

\begin_layout Enumerate
The vault passes this request on to his peers who are also saving the chunk.
 It is up to the peers to delete the chunk, this vault's contract of saving
 is signed off and complete on receipt of this signed request.
\end_layout

\begin_layout Enumerate
If the signature does not match the request is silently dropped, and a system
 alert is generated [ALERT_ATTEMPTED_UNAUTHORISED_DELETE].
\end_layout

\begin_layout Enumerate
If there is no signature then the content is hashed and compared with name,
 to ensure integrity.
\end_layout

\begin_layout Enumerate
If it is a valid data chunk the requester ID is removed from the [WATCHINGchunkn
ame] list.
 (this list is an arbitrary figure long - say 10 entries, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Chunk-lifetimes-and"

\end_inset

 ).
\end_layout

\begin_layout Enumerate
If data chunk and no ID's are left in the list then the chunk is marked
 for delete in 60 days.
 
\end_layout

\begin_layout Subsubsection
Chunk Lifetimes and Duplicate Removal
\begin_inset CommandInset label
LatexCommand label
name "sub:Chunk-lifetimes-and"

\end_inset


\end_layout

\begin_layout Standard
As data chunks have a delete time of 60 days all clients MUST check their
 chunks every 45 days at most.
 When either a client checks his chunks OR on initial backup then the following
 holds true:
\end_layout

\begin_layout Enumerate
vault runs the store data on network process as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Store-Data-on"

\end_inset


\end_layout

\begin_layout Enumerate
If the chunks are already there OR this is a check on chunks.
\end_layout

\begin_layout Enumerate
The vault checks chunk availability (validity is done elsewhere).
\end_layout

\begin_layout Enumerate
Then vault checks the [WATCHINGchunkname] database to ensure either, there
 are at least 10 vaults listed or else it adds its own signed name to this
 list (
\begin_inset Formula $RSAsign_{[MAID]}(MAID-chunkname)$
\end_inset

 (where MAID is MAID ID)
\end_layout

\begin_layout Enumerate
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The cost for adding the name to the list is a degree of how many people
 are also watching the chunk.
 This for now is a direct calculation starting at 1st name pays 100% of
 chunk cost (i.e.
 gives us same amount of space as the chunk), 2nd name pays 1/2 third 1/3
 etc.
 In many cases a database can be written for the vault [OWESchunknode] with
 the outstanding payment written and co-signed by both vaults.
 This can be redeemed when the vault negotiates with another chunk, i.e.
 the database can be added up to a full chunk and paid, failure to pay will
 cost on ranking.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Messenger System (Version 1.0)
\begin_inset CommandInset label
LatexCommand label
name "sub:Messenger-system-(version"

\end_inset


\end_layout

\begin_layout Standard
The initial messaging system will not be real time but will use a buffer
 packet as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generic-BUFFER-packet"

\end_inset

.
 This chunk is the hash of MPID+BUFFER and contains all user system messages.
\end_layout

\begin_layout Itemize
\begin_inset Formula $RSAsign_{c1[privkey]}(RSAenc_{[c2pub\, key]}(\hat{DF}))\rightarrow C_{2}[MPIDBUFFER]$
\end_inset


\end_layout

\begin_layout Itemize
where C1 and C2 are MPID nodes on the network sharing data.
\end_layout

\begin_layout Subsection
Private Data Sharing
\end_layout

\begin_layout Standard
[rely on share
\begin_inset Formula $ $
\end_inset


\begin_inset Formula $\subset$
\end_inset

DA and a subset of 
\begin_inset Formula $\subset\hat{Df}$
\end_inset

]
\end_layout

\begin_layout Enumerate
\begin_inset Formula $sharename\equiv Ns$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $DA\equiv unser(DA)\equiv\hat{DA}$
\end_inset


\end_layout

\begin_layout Enumerate
select data maps as created in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-maps"

\end_inset


\end_layout

\begin_layout Enumerate
select data Metadata from section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-maps"

\end_inset


\end_layout

\begin_layout Enumerate
Select rights for each file and the share itself (addfiles/deletefiles/updatefil
es/addusers/delusers/updateusers)
\end_layout

\begin_layout Enumerate
concatenate
\end_layout

\begin_layout Enumerate
serialise into share called Ns
\end_layout

\begin_layout Enumerate
send sys message to public name you are sharing with (in a buffer message
 as in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generic-BUFFER-packet"

\end_inset

)
\end_layout

\begin_layout Enumerate
Any share actions and all participants are messaged (file lock / updates
 - everything)
\end_layout

\begin_layout Standard
Therefore 
\end_layout

\begin_layout Standard
(all communications via a buffer packet for each user)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $DA\equiv unser(DA)\equiv\hat{DA}$
\end_inset


\end_layout

\begin_layout Enumerate
Assume C1 is client 1 (MPID
\begin_inset Formula $_{1}$
\end_inset

) C2 is (MPID
\begin_inset Formula $_{2}$
\end_inset

)
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\begin_layout Enumerate
So 
\begin_inset Formula $C1[DA]\equiv unser(DA)\equiv\hat{DA}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $MSID_{1}$
\end_inset


\begin_inset Formula $\subset DA$
\end_inset

 ([defines share as a subset of DA)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $MSID_{1}\equiv sharename$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $MSID_{1}\rightarrow RSAsignC_{c1}(MSID_{1})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $C_{2}\rightarrow C_{1}RSAsign_{C2}(acept_{share}(C_{2})$
\end_inset

Share accepted
\end_layout

\begin_layout Enumerate
\begin_inset Formula $C_{1}\rightarrow MSID_{1}\rightarrow C_{2}$
\end_inset

 (share transferred (including data maps and Metadata maps)
\end_layout

\begin_layout Enumerate
If C
\begin_inset Formula $_{1}OR],C_{c}add/delete/edit\, a\, file\, then\, C_{2\,}C_{1}sends\, message\, to\, other\, client\, to\, lock$
\end_inset


\end_layout

\begin_layout Standard
message format
\end_layout

\begin_layout Itemize
\begin_inset Formula $Sign_{[C_{1}]}(\hat{DF})\rightarrow C_{2}(lock\, etc)$
\end_inset


\end_layout

\begin_layout Section
Additional Benefits
\end_layout

\begin_layout Subsection
Duplicate Prevention
\end_layout

\begin_layout Standard
As we saw in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Self-encryption"

\end_inset

 the data in this proposal is encrypted using information contained within
 the data.
 It is the data map that holds the keys and sources of any file or other
 piece of digital data.
\end_layout

\begin_layout Standard
It has been suggested in tests done at a local level that this could achieve
 a reduction in hard drive space required to store all the world's data.
 Tests by EMC on a local duplicate removal system (in a single LAN) showed
 saving 10 to 25 times the disk space used by data.
 maidsafe imagine this would mean a reduction in disk space required today
 - or a reclamation of disk space of somewhere between 60 - 90%, although
 only real world testing will provide the definitive answer.
 Update ! a recent study by datamoniotor puts savings from 4 /1 to 89 /1
 with an average at enterprise level of 20 /1 i.e.
 20Gb can be backed up on 1 Gb space, therefore 95% savings.
\end_layout

\begin_layout Subsection
Mobility
\end_layout

\begin_layout Standard
Log in to your data from any maidsafe enabled device from any Internet location.
 
\end_layout

\begin_layout Subsection
Data-Loss Prevention
\end_layout

\begin_layout Standard
[search for known chunks]
\end_layout

\begin_layout Subsection
Virus Resistance
\end_layout

\begin_layout Standard
[dirty data]
\end_layout

\begin_layout Subsection
Web Site Logins with No Password
\end_layout

\begin_layout Standard
[PD signs requests using public or anon ID's]
\end_layout

\begin_layout Section
Future Trends
\end_layout

\begin_layout Standard
The future of this type of technology is a bright one.
 A self managed digital ID which can spawn as many ID's as the system or
 the user decides it should (SHA512 hashes allow for 
\begin_inset Formula $2x10^{154}$
\end_inset

 results which equates to more hashes than atoms in the visible universe).
\end_layout

\begin_layout Standard
With a digital ID people could do many interesting things such as:
\end_layout

\begin_layout Subsection
Perpetual Coin
\end_layout

\begin_layout Standard
A cryptographically secure digital ID with which any human can carry out
 interaction on the Internet as an anonymous but fully-authenticated entity.
 Current practice requires authentication by a third party.
 Logging in to PayPal is an example.
 With a maidsafe System, a member can log in from any networked computer
 in the world.
 The Login process takes place on the local computer and involves only the
 user and the software.
 No password is ever transmitted.
 This ID can be used for anonymous self-authenticated voting, for file sharing
 and for commercial exchange.
 
\end_layout

\begin_layout Standard
Digital coin, like the gold coin of old, is a thing.
 It is a modular unit of software that can: 
\end_layout

\begin_layout Enumerate
be subdivided or combined, and be appropriately re-denominated to any decimal
 place; 
\end_layout

\begin_layout Enumerate
remember and display the contractual agreement from which it originated;
 
\end_layout

\begin_layout Enumerate
perform internal calculations according to pre-set formula, and, 
\end_layout

\begin_layout Enumerate
autonomously access the Internet for variables to input into said formula.
 
\end_layout

\begin_layout Standard
Digital coinâ€™s usefulness as a trading medium is unprecedented and unsurpassed.
 Digital coin can be instantly transferred via the Internet but never copied.
 Each unit of digital coin will have a unique identifier and be digitally
 signed by its owner while in that ownerâ€™s possession.
 No one else will be able to spend it.
 This digital signature will be completely erased when the next ownerâ€™s
 digital signature is imprinted, maintaining anonymity.
 Parties to transactions may be anonymous, using a Digital ID, verified
 by self-authentication.
 At all times the total amount of digital coin in existence will be finite,
 easily determined and publicly available.
 
\end_layout

\begin_layout Standard
[some maths]
\end_layout

\begin_layout Subsection
Digitally Validated Voting
\end_layout

\begin_layout Standard
The ability to vote digitally and securely is inherent now with this design,
 but a major new situation is possible and this is vote validation.
\end_layout

\begin_layout Standard
[some maths]
\end_layout

\begin_layout Subsection
Solid State Stand Alone Chunk nodes
\end_layout

\begin_layout Standard
Low power, 'plug and play' devices with little processing (vaults do not
 encrypt or decrypt) and attached to a network could expand the network's
 data storage capabilities automatically.
 To add or remove data storage it would be a matter of plugging in these
 devices.
 
\end_layout

\begin_layout Subsection
Read Only Operating System
\end_layout

\begin_layout Standard
[benefits - no firewall no virus]
\end_layout

\begin_layout Subsection
USB Computer
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\]

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
Results of testing so far are:
\end_layout

\begin_layout Standard
Time to self encrypt files (1Mb = 0.2secs) - table to follow
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
The Kademlia protocol will require to be updated as time goes by, this has
 already been tested
\begin_inset CommandInset citation
LatexCommand cite
key "key-16"

\end_inset

 and should be included in the version 1.0 release of such a system.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-10"

\end_inset

as described by Van Jacobson in this link below, August 30, 2006 HTTP://video.Goo
gle.com/videoplay?docid=-6972678839686672840
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-15"

\end_inset

PETAR MAYMOUNKOV AND DAVID MAZI`RESE Kademlia: A Peer-to-peer Information
 System Based on the XOR Metric {petar,dm}@cs.nyu.edu http://kademlia.scs.cs.nyu.edu
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-16"

\end_inset

ANDREAS BINZENH Ìˆ FER AND HOLGER SCHNABEL.
 Improving the Performance and Robustness of Kademlia-based Overlay Networks
 o University of W Ìˆ rzburg, Institute of Computer Science u Chair of Distribute
d Systems, W Ìˆ rzburg, Germany u Email: binzenhoefer@informatik.uni-wuerzburg.de
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

RATNASAMY, S., FRANCIS, P., HANDLEY, M., KARP, R., AND SHENKER, S.
 A scalable content-addressable network.
 In Proc.
 ACM SIGCOMM (San Diego, 2001).
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

ROWSTRON, A., AND DRUSCHEL, P.
 Storage management and caching in PAST, a large-scale, persistent peer-to-peer
 storage utility.
 In Proceedings of the 18th ACM Symposium on Operating Systems Principles
 (Oct.
 2001).
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

ZHAO, B., KUBIATOWICZ, J., AND JOSEPH, A.
 Tapestry: An infrastructure for fault-tolerant wide-area location and routing.
 Tech.
 Rep.
 UCB/CSD-01-1141, Computer Science Division, U.
 C.
 Berkeley, Apr.
 2001.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

FRANK DABEK, M.
 FRANS KAASHOEK, DAVID KARGER, ROBERT MORRIS, ION STOICA.
 Wide-area cooperative storage with CFS MIT Laboratory for Computer Science
 chord@lcs.mit.edu http://pdos.lcs.mit.edu/chord/
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

CLARKE, I., SANDBERG, O., WILEY, B., AND HONG, T.
 Freenet: A distributed anonymous information storage and retrieval system.
 In Proceedings of the Workshop on Design Issues in Anonymity and Unobservabilit
y (July 2000), pp.
 46â€“66.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

KARGER, D., LEHMAN, E., LEIGHTON, T., LEVINE, M., LEWIN, D., AND PANIGRAHY, R.
 Consistent hashing and random trees: Distributed caching protocols for
 relieving hot spots on the world wide web.
 In Proceedings of the 29th Annual ACM Symposium on Theory of Computing
 (May 1997), pp.
 654â€“663.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"

\end_inset

JINYANG LI, JEREMY STRIBLING, THOMER M.
 GIL, ROBERT MORRIS, M.
 FRANS KAASHOEK.
 Comparing the performance of distributed hash tables under churn: MIT Computer
 Science and Artificial Intelligence Laboratory {jinyang, strib, thomer,
 rtm, kaashoek}@csail.mit.edu
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-8"

\end_inset

Jun Xu.
 On the fundamental tradeoffs between routing table size and network diameter
 in peer-to-peer networks.
 In Proceedings of the IEEE Infocom, March 2003.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-9"

\end_inset

Philip Hawkes , Michael Paddon , and Gregory G.
 Rose, On Corrective Patterns for the SHA-2 Family, Qualcomm Australia,
 Level 3, 230 Victoria Rd, Gladesville, NSW 2111, Australia
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "13"
key "key-1"

\end_inset

Yunhong Gu, Robert L Grossman, UDT: UDP-based data transfer for high-speed
 wide area networks 
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Change this paragraphs style to 'Standard' to enable
\end_layout

\begin_layout Plain Layout
BibTeX bibliography generation.
\end_layout

\begin_layout Plain Layout
Remember though that your final submission is supposed to have
\end_layout

\begin_layout Plain Layout
all the bibliography entries embedded in the latex file.
 This means
\end_layout

\begin_layout Plain Layout
you eventually have to copy the .bbl file into the latex file and
\end_layout

\begin_layout Plain Layout
remove the bibtex lines.
\end_layout

\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "your_biblio_file"
options "IEEEbib"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout BiographyNoPhoto
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

David Irvine
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 A Scottish Engineer and innovator who has spent the last 12 years researching
 ways to make computers function in a better way.
 Listed as sole inventor on 11 patent submissions and designer of one of
 the worlds largest private networks.
 He rarely stops working on algorithms and problems looking for better ways.
 He also enjoys sailing and the company of imaginative people.
\end_layout

\end_body
\end_document
