// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_kademlia_5fservice_5fmessages_2eproto__INCLUDED
#define PROTOBUF_kademlia_5fservice_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "contact_info.pb.h"

namespace kad {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto();
void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class PingRequest;
class PingResponse;
class FindRequest;
class FindResponse;
class FindNodeResult;
class StoreRequest;
class StoreResponse;
class DownlistRequest;
class DownlistResponse;
class BootstrapRequest;
class BootstrapResponse;
class NatDetectionRequest;
class NatDetectionResponse;
class NatDetectionPingRequest;
class NatDetectionPingResponse;

// ===================================================================

class PingRequest : public ::google::protobuf::Message {
 public:
  PingRequest();
  virtual ~PingRequest();
  
  PingRequest(const PingRequest& from);
  
  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRequest& default_instance();
  void Swap(PingRequest* other);
  
  // implements Message ----------------------------------------------
  
  PingRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes ping = 1;
  inline bool has_ping() const;
  inline void clear_ping();
  inline const ::std::string& ping() const;
  inline void set_ping(const ::std::string& value);
  inline void set_ping(const char* value);
  inline void set_ping(const void* value, size_t size);
  inline ::std::string* mutable_ping();
  
  // required .kad.ContactInfo sender_info = 2;
  inline bool has_sender_info() const;
  inline void clear_sender_info();
  inline const ::kad::ContactInfo& sender_info() const;
  inline ::kad::ContactInfo* mutable_sender_info();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ping_;
  static const ::std::string _default_ping_;
  ::kad::ContactInfo* sender_info_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PingRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingResponse : public ::google::protobuf::Message {
 public:
  PingResponse();
  virtual ~PingResponse();
  
  PingResponse(const PingResponse& from);
  
  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingResponse& default_instance();
  void Swap(PingResponse* other);
  
  // implements Message ----------------------------------------------
  
  PingResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes echo = 2;
  inline bool has_echo() const;
  inline void clear_echo();
  inline const ::std::string& echo() const;
  inline void set_echo(const ::std::string& value);
  inline void set_echo(const char* value);
  inline void set_echo(const void* value, size_t size);
  inline ::std::string* mutable_echo();
  
  // optional bytes node_id = 3;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* echo_;
  static const ::std::string _default_echo_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PingResponse* default_instance_;
};
// -------------------------------------------------------------------

class FindRequest : public ::google::protobuf::Message {
 public:
  FindRequest();
  virtual ~FindRequest();
  
  FindRequest(const FindRequest& from);
  
  inline FindRequest& operator=(const FindRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindRequest& default_instance();
  void Swap(FindRequest* other);
  
  // implements Message ----------------------------------------------
  
  FindRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required .kad.ContactInfo sender_info = 2;
  inline bool has_sender_info() const;
  inline void clear_sender_info();
  inline const ::kad::ContactInfo& sender_info() const;
  inline ::kad::ContactInfo* mutable_sender_info();
  
  // optional bool is_boostrap = 3;
  inline bool has_is_boostrap() const;
  inline void clear_is_boostrap();
  inline bool is_boostrap() const;
  inline void set_is_boostrap(bool value);
  
  // optional bytes sender_ext_ip = 4;
  inline bool has_sender_ext_ip() const;
  inline void clear_sender_ext_ip();
  inline const ::std::string& sender_ext_ip() const;
  inline void set_sender_ext_ip(const ::std::string& value);
  inline void set_sender_ext_ip(const char* value);
  inline void set_sender_ext_ip(const void* value, size_t size);
  inline ::std::string* mutable_sender_ext_ip();
  
  // optional int32 sender_ext_port = 5;
  inline bool has_sender_ext_port() const;
  inline void clear_sender_ext_port();
  inline ::google::protobuf::int32 sender_ext_port() const;
  inline void set_sender_ext_port(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::kad::ContactInfo* sender_info_;
  bool is_boostrap_;
  ::std::string* sender_ext_ip_;
  static const ::std::string _default_sender_ext_ip_;
  ::google::protobuf::int32 sender_ext_port_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FindRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindResponse : public ::google::protobuf::Message {
 public:
  FindResponse();
  virtual ~FindResponse();
  
  FindResponse(const FindResponse& from);
  
  inline FindResponse& operator=(const FindResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindResponse& default_instance();
  void Swap(FindResponse* other);
  
  // implements Message ----------------------------------------------
  
  FindResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // repeated bytes closest_nodes = 2;
  inline int closest_nodes_size() const;
  inline void clear_closest_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& closest_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_closest_nodes();
  inline const ::std::string& closest_nodes(int index) const;
  inline ::std::string* mutable_closest_nodes(int index);
  inline void set_closest_nodes(int index, const ::std::string& value);
  inline void set_closest_nodes(int index, const char* value);
  inline ::std::string* add_closest_nodes();
  inline void add_closest_nodes(const ::std::string& value);
  inline void add_closest_nodes(const char* value);
  inline void set_closest_nodes(int index, const void* value, size_t size);
  inline void add_closest_nodes(const void* value, size_t size);
  
  // repeated bytes values = 3;
  inline int values_size() const;
  inline void clear_values();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void set_values(int index, const void* value, size_t size);
  inline void add_values(const void* value, size_t size);
  
  // optional bytes requester_ext_addr = 4;
  inline bool has_requester_ext_addr() const;
  inline void clear_requester_ext_addr();
  inline const ::std::string& requester_ext_addr() const;
  inline void set_requester_ext_addr(const ::std::string& value);
  inline void set_requester_ext_addr(const char* value);
  inline void set_requester_ext_addr(const void* value, size_t size);
  inline ::std::string* mutable_requester_ext_addr();
  
  // optional bytes node_id = 5;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> closest_nodes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::std::string* requester_ext_addr_;
  static const ::std::string _default_requester_ext_addr_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FindResponse* default_instance_;
};
// -------------------------------------------------------------------

class FindNodeResult : public ::google::protobuf::Message {
 public:
  FindNodeResult();
  virtual ~FindNodeResult();
  
  FindNodeResult(const FindNodeResult& from);
  
  inline FindNodeResult& operator=(const FindNodeResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindNodeResult& default_instance();
  void Swap(FindNodeResult* other);
  
  // implements Message ----------------------------------------------
  
  FindNodeResult* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes contact = 2;
  inline bool has_contact() const;
  inline void clear_contact();
  inline const ::std::string& contact() const;
  inline void set_contact(const ::std::string& value);
  inline void set_contact(const char* value);
  inline void set_contact(const void* value, size_t size);
  inline ::std::string* mutable_contact();
  
  // optional bytes node_id = 3;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* contact_;
  static const ::std::string _default_contact_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FindNodeResult* default_instance_;
};
// -------------------------------------------------------------------

class StoreRequest : public ::google::protobuf::Message {
 public:
  StoreRequest();
  virtual ~StoreRequest();
  
  StoreRequest(const StoreRequest& from);
  
  inline StoreRequest& operator=(const StoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreRequest& default_instance();
  void Swap(StoreRequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 5;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required .kad.ContactInfo sender_info = 6;
  inline bool has_sender_info() const;
  inline void clear_sender_info();
  inline const ::kad::ContactInfo& sender_info() const;
  inline ::kad::ContactInfo* mutable_sender_info();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::kad::ContactInfo* sender_info_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreResponse : public ::google::protobuf::Message {
 public:
  StoreResponse();
  virtual ~StoreResponse();
  
  StoreResponse(const StoreResponse& from);
  
  inline StoreResponse& operator=(const StoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreResponse& default_instance();
  void Swap(StoreResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class DownlistRequest : public ::google::protobuf::Message {
 public:
  DownlistRequest();
  virtual ~DownlistRequest();
  
  DownlistRequest(const DownlistRequest& from);
  
  inline DownlistRequest& operator=(const DownlistRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownlistRequest& default_instance();
  void Swap(DownlistRequest* other);
  
  // implements Message ----------------------------------------------
  
  DownlistRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes downlist = 1;
  inline int downlist_size() const;
  inline void clear_downlist();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& downlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_downlist();
  inline const ::std::string& downlist(int index) const;
  inline ::std::string* mutable_downlist(int index);
  inline void set_downlist(int index, const ::std::string& value);
  inline void set_downlist(int index, const char* value);
  inline ::std::string* add_downlist();
  inline void add_downlist(const ::std::string& value);
  inline void add_downlist(const char* value);
  inline void set_downlist(int index, const void* value, size_t size);
  inline void add_downlist(const void* value, size_t size);
  
  // required .kad.ContactInfo sender_info = 2;
  inline bool has_sender_info() const;
  inline void clear_sender_info();
  inline const ::kad::ContactInfo& sender_info() const;
  inline ::kad::ContactInfo* mutable_sender_info();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> downlist_;
  ::kad::ContactInfo* sender_info_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DownlistRequest* default_instance_;
};
// -------------------------------------------------------------------

class DownlistResponse : public ::google::protobuf::Message {
 public:
  DownlistResponse();
  virtual ~DownlistResponse();
  
  DownlistResponse(const DownlistResponse& from);
  
  inline DownlistResponse& operator=(const DownlistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DownlistResponse& default_instance();
  void Swap(DownlistResponse* other);
  
  // implements Message ----------------------------------------------
  
  DownlistResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* node_id_;
  static const ::std::string _default_node_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DownlistResponse* default_instance_;
};
// -------------------------------------------------------------------

class BootstrapRequest : public ::google::protobuf::Message {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();
  
  BootstrapRequest(const BootstrapRequest& from);
  
  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapRequest& default_instance();
  void Swap(BootstrapRequest* other);
  
  // implements Message ----------------------------------------------
  
  BootstrapRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes newcomer_id = 1;
  inline bool has_newcomer_id() const;
  inline void clear_newcomer_id();
  inline const ::std::string& newcomer_id() const;
  inline void set_newcomer_id(const ::std::string& value);
  inline void set_newcomer_id(const char* value);
  inline void set_newcomer_id(const void* value, size_t size);
  inline ::std::string* mutable_newcomer_id();
  
  // required bytes newcomer_local_ip = 2;
  inline bool has_newcomer_local_ip() const;
  inline void clear_newcomer_local_ip();
  inline const ::std::string& newcomer_local_ip() const;
  inline void set_newcomer_local_ip(const ::std::string& value);
  inline void set_newcomer_local_ip(const char* value);
  inline void set_newcomer_local_ip(const void* value, size_t size);
  inline ::std::string* mutable_newcomer_local_ip();
  
  // required int32 newcomer_local_port = 3;
  inline bool has_newcomer_local_port() const;
  inline void clear_newcomer_local_port();
  inline ::google::protobuf::int32 newcomer_local_port() const;
  inline void set_newcomer_local_port(::google::protobuf::int32 value);
  
  // optional bytes newcomer_ext_ip = 4;
  inline bool has_newcomer_ext_ip() const;
  inline void clear_newcomer_ext_ip();
  inline const ::std::string& newcomer_ext_ip() const;
  inline void set_newcomer_ext_ip(const ::std::string& value);
  inline void set_newcomer_ext_ip(const char* value);
  inline void set_newcomer_ext_ip(const void* value, size_t size);
  inline ::std::string* mutable_newcomer_ext_ip();
  
  // optional int32 newcomer_ext_port = 5;
  inline bool has_newcomer_ext_port() const;
  inline void clear_newcomer_ext_port();
  inline ::google::protobuf::int32 newcomer_ext_port() const;
  inline void set_newcomer_ext_port(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* newcomer_id_;
  static const ::std::string _default_newcomer_id_;
  ::std::string* newcomer_local_ip_;
  static const ::std::string _default_newcomer_local_ip_;
  ::google::protobuf::int32 newcomer_local_port_;
  ::std::string* newcomer_ext_ip_;
  static const ::std::string _default_newcomer_ext_ip_;
  ::google::protobuf::int32 newcomer_ext_port_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BootstrapRequest* default_instance_;
};
// -------------------------------------------------------------------

class BootstrapResponse : public ::google::protobuf::Message {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();
  
  BootstrapResponse(const BootstrapResponse& from);
  
  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapResponse& default_instance();
  void Swap(BootstrapResponse* other);
  
  // implements Message ----------------------------------------------
  
  BootstrapResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes bootstrap_id = 2;
  inline bool has_bootstrap_id() const;
  inline void clear_bootstrap_id();
  inline const ::std::string& bootstrap_id() const;
  inline void set_bootstrap_id(const ::std::string& value);
  inline void set_bootstrap_id(const char* value);
  inline void set_bootstrap_id(const void* value, size_t size);
  inline ::std::string* mutable_bootstrap_id();
  
  // optional bytes newcomer_ext_ip = 3;
  inline bool has_newcomer_ext_ip() const;
  inline void clear_newcomer_ext_ip();
  inline const ::std::string& newcomer_ext_ip() const;
  inline void set_newcomer_ext_ip(const ::std::string& value);
  inline void set_newcomer_ext_ip(const char* value);
  inline void set_newcomer_ext_ip(const void* value, size_t size);
  inline ::std::string* mutable_newcomer_ext_ip();
  
  // optional int32 newcomer_ext_port = 4;
  inline bool has_newcomer_ext_port() const;
  inline void clear_newcomer_ext_port();
  inline ::google::protobuf::int32 newcomer_ext_port() const;
  inline void set_newcomer_ext_port(::google::protobuf::int32 value);
  
  // optional int32 nat_type = 5;
  inline bool has_nat_type() const;
  inline void clear_nat_type();
  inline ::google::protobuf::int32 nat_type() const;
  inline void set_nat_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* bootstrap_id_;
  static const ::std::string _default_bootstrap_id_;
  ::std::string* newcomer_ext_ip_;
  static const ::std::string _default_newcomer_ext_ip_;
  ::google::protobuf::int32 newcomer_ext_port_;
  ::google::protobuf::int32 nat_type_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BootstrapResponse* default_instance_;
};
// -------------------------------------------------------------------

class NatDetectionRequest : public ::google::protobuf::Message {
 public:
  NatDetectionRequest();
  virtual ~NatDetectionRequest();
  
  NatDetectionRequest(const NatDetectionRequest& from);
  
  inline NatDetectionRequest& operator=(const NatDetectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectionRequest& default_instance();
  void Swap(NatDetectionRequest* other);
  
  // implements Message ----------------------------------------------
  
  NatDetectionRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes newcomer = 1;
  inline bool has_newcomer() const;
  inline void clear_newcomer();
  inline const ::std::string& newcomer() const;
  inline void set_newcomer(const ::std::string& value);
  inline void set_newcomer(const char* value);
  inline void set_newcomer(const void* value, size_t size);
  inline ::std::string* mutable_newcomer();
  
  // required bytes bootstrap_node = 2;
  inline bool has_bootstrap_node() const;
  inline void clear_bootstrap_node();
  inline const ::std::string& bootstrap_node() const;
  inline void set_bootstrap_node(const ::std::string& value);
  inline void set_bootstrap_node(const char* value);
  inline void set_bootstrap_node(const void* value, size_t size);
  inline ::std::string* mutable_bootstrap_node();
  
  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required bytes sender_id = 4;
  inline bool has_sender_id() const;
  inline void clear_sender_id();
  inline const ::std::string& sender_id() const;
  inline void set_sender_id(const ::std::string& value);
  inline void set_sender_id(const char* value);
  inline void set_sender_id(const void* value, size_t size);
  inline ::std::string* mutable_sender_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* newcomer_;
  static const ::std::string _default_newcomer_;
  ::std::string* bootstrap_node_;
  static const ::std::string _default_bootstrap_node_;
  ::google::protobuf::int32 type_;
  ::std::string* sender_id_;
  static const ::std::string _default_sender_id_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NatDetectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class NatDetectionResponse : public ::google::protobuf::Message {
 public:
  NatDetectionResponse();
  virtual ~NatDetectionResponse();
  
  NatDetectionResponse(const NatDetectionResponse& from);
  
  inline NatDetectionResponse& operator=(const NatDetectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectionResponse& default_instance();
  void Swap(NatDetectionResponse* other);
  
  // implements Message ----------------------------------------------
  
  NatDetectionResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NatDetectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class NatDetectionPingRequest : public ::google::protobuf::Message {
 public:
  NatDetectionPingRequest();
  virtual ~NatDetectionPingRequest();
  
  NatDetectionPingRequest(const NatDetectionPingRequest& from);
  
  inline NatDetectionPingRequest& operator=(const NatDetectionPingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectionPingRequest& default_instance();
  void Swap(NatDetectionPingRequest* other);
  
  // implements Message ----------------------------------------------
  
  NatDetectionPingRequest* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes ping = 1;
  inline bool has_ping() const;
  inline void clear_ping();
  inline const ::std::string& ping() const;
  inline void set_ping(const ::std::string& value);
  inline void set_ping(const char* value);
  inline void set_ping(const void* value, size_t size);
  inline ::std::string* mutable_ping();
  
  // required .kad.ContactInfo sender_info = 2;
  inline bool has_sender_info() const;
  inline void clear_sender_info();
  inline const ::kad::ContactInfo& sender_info() const;
  inline ::kad::ContactInfo* mutable_sender_info();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ping_;
  static const ::std::string _default_ping_;
  ::kad::ContactInfo* sender_info_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NatDetectionPingRequest* default_instance_;
};
// -------------------------------------------------------------------

class NatDetectionPingResponse : public ::google::protobuf::Message {
 public:
  NatDetectionPingResponse();
  virtual ~NatDetectionPingResponse();
  
  NatDetectionPingResponse(const NatDetectionPingResponse& from);
  
  inline NatDetectionPingResponse& operator=(const NatDetectionPingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NatDetectionPingResponse& default_instance();
  void Swap(NatDetectionPingResponse* other);
  
  // implements Message ----------------------------------------------
  
  NatDetectionPingResponse* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes echo = 2;
  inline bool has_echo() const;
  inline void clear_echo();
  inline const ::std::string& echo() const;
  inline void set_echo(const ::std::string& value);
  inline void set_echo(const char* value);
  inline void set_echo(const void* value, size_t size);
  inline ::std::string* mutable_echo();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* echo_;
  static const ::std::string _default_echo_;
  friend void protobuf_BuildDesc_kademlia_5fservice_5fmessages_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NatDetectionPingResponse* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// PingRequest

// required bytes ping = 1;
inline bool PingRequest::has_ping() const {
  return _has_bit(0);
}
inline void PingRequest::clear_ping() {
  if (ping_ != &_default_ping_) {
    ping_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PingRequest::ping() const {
  return *ping_;
}
inline void PingRequest::set_ping(const ::std::string& value) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void PingRequest::set_ping(const char* value) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void PingRequest::set_ping(const void* value, size_t size) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingRequest::mutable_ping() {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  return ping_;
}

// required .kad.ContactInfo sender_info = 2;
inline bool PingRequest::has_sender_info() const {
  return _has_bit(1);
}
inline void PingRequest::clear_sender_info() {
  if (sender_info_ != NULL) sender_info_->::kad::ContactInfo::Clear();
  _clear_bit(1);
}
inline const ::kad::ContactInfo& PingRequest::sender_info() const {
  return sender_info_ != NULL ? *sender_info_ : *default_instance_->sender_info_;
}
inline ::kad::ContactInfo* PingRequest::mutable_sender_info() {
  _set_bit(1);
  if (sender_info_ == NULL) sender_info_ = new ::kad::ContactInfo;
  return sender_info_;
}

// -------------------------------------------------------------------

// PingResponse

// required bytes result = 1;
inline bool PingResponse::has_result() const {
  return _has_bit(0);
}
inline void PingResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PingResponse::result() const {
  return *result_;
}
inline void PingResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void PingResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void PingResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes echo = 2;
inline bool PingResponse::has_echo() const {
  return _has_bit(1);
}
inline void PingResponse::clear_echo() {
  if (echo_ != &_default_echo_) {
    echo_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PingResponse::echo() const {
  return *echo_;
}
inline void PingResponse::set_echo(const ::std::string& value) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(value);
}
inline void PingResponse::set_echo(const char* value) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(value);
}
inline void PingResponse::set_echo(const void* value, size_t size) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingResponse::mutable_echo() {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  return echo_;
}

// optional bytes node_id = 3;
inline bool PingResponse::has_node_id() const {
  return _has_bit(2);
}
inline void PingResponse::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PingResponse::node_id() const {
  return *node_id_;
}
inline void PingResponse::set_node_id(const ::std::string& value) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void PingResponse::set_node_id(const char* value) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void PingResponse::set_node_id(const void* value, size_t size) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingResponse::mutable_node_id() {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// -------------------------------------------------------------------

// FindRequest

// required bytes key = 1;
inline bool FindRequest::has_key() const {
  return _has_bit(0);
}
inline void FindRequest::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FindRequest::key() const {
  return *key_;
}
inline void FindRequest::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void FindRequest::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void FindRequest::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindRequest::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required .kad.ContactInfo sender_info = 2;
inline bool FindRequest::has_sender_info() const {
  return _has_bit(1);
}
inline void FindRequest::clear_sender_info() {
  if (sender_info_ != NULL) sender_info_->::kad::ContactInfo::Clear();
  _clear_bit(1);
}
inline const ::kad::ContactInfo& FindRequest::sender_info() const {
  return sender_info_ != NULL ? *sender_info_ : *default_instance_->sender_info_;
}
inline ::kad::ContactInfo* FindRequest::mutable_sender_info() {
  _set_bit(1);
  if (sender_info_ == NULL) sender_info_ = new ::kad::ContactInfo;
  return sender_info_;
}

// optional bool is_boostrap = 3;
inline bool FindRequest::has_is_boostrap() const {
  return _has_bit(2);
}
inline void FindRequest::clear_is_boostrap() {
  is_boostrap_ = false;
  _clear_bit(2);
}
inline bool FindRequest::is_boostrap() const {
  return is_boostrap_;
}
inline void FindRequest::set_is_boostrap(bool value) {
  _set_bit(2);
  is_boostrap_ = value;
}

// optional bytes sender_ext_ip = 4;
inline bool FindRequest::has_sender_ext_ip() const {
  return _has_bit(3);
}
inline void FindRequest::clear_sender_ext_ip() {
  if (sender_ext_ip_ != &_default_sender_ext_ip_) {
    sender_ext_ip_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& FindRequest::sender_ext_ip() const {
  return *sender_ext_ip_;
}
inline void FindRequest::set_sender_ext_ip(const ::std::string& value) {
  _set_bit(3);
  if (sender_ext_ip_ == &_default_sender_ext_ip_) {
    sender_ext_ip_ = new ::std::string;
  }
  sender_ext_ip_->assign(value);
}
inline void FindRequest::set_sender_ext_ip(const char* value) {
  _set_bit(3);
  if (sender_ext_ip_ == &_default_sender_ext_ip_) {
    sender_ext_ip_ = new ::std::string;
  }
  sender_ext_ip_->assign(value);
}
inline void FindRequest::set_sender_ext_ip(const void* value, size_t size) {
  _set_bit(3);
  if (sender_ext_ip_ == &_default_sender_ext_ip_) {
    sender_ext_ip_ = new ::std::string;
  }
  sender_ext_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindRequest::mutable_sender_ext_ip() {
  _set_bit(3);
  if (sender_ext_ip_ == &_default_sender_ext_ip_) {
    sender_ext_ip_ = new ::std::string;
  }
  return sender_ext_ip_;
}

// optional int32 sender_ext_port = 5;
inline bool FindRequest::has_sender_ext_port() const {
  return _has_bit(4);
}
inline void FindRequest::clear_sender_ext_port() {
  sender_ext_port_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FindRequest::sender_ext_port() const {
  return sender_ext_port_;
}
inline void FindRequest::set_sender_ext_port(::google::protobuf::int32 value) {
  _set_bit(4);
  sender_ext_port_ = value;
}

// -------------------------------------------------------------------

// FindResponse

// required bytes result = 1;
inline bool FindResponse::has_result() const {
  return _has_bit(0);
}
inline void FindResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FindResponse::result() const {
  return *result_;
}
inline void FindResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void FindResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void FindResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// repeated bytes closest_nodes = 2;
inline int FindResponse::closest_nodes_size() const {
  return closest_nodes_.size();
}
inline void FindResponse::clear_closest_nodes() {
  closest_nodes_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindResponse::closest_nodes() const {
  return closest_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindResponse::mutable_closest_nodes() {
  return &closest_nodes_;
}
inline const ::std::string& FindResponse::closest_nodes(int index) const {
  return closest_nodes_.Get(index);
}
inline ::std::string* FindResponse::mutable_closest_nodes(int index) {
  return closest_nodes_.Mutable(index);
}
inline void FindResponse::set_closest_nodes(int index, const ::std::string& value) {
  closest_nodes_.Mutable(index)->assign(value);
}
inline void FindResponse::set_closest_nodes(int index, const char* value) {
  closest_nodes_.Mutable(index)->assign(value);
}
inline ::std::string* FindResponse::add_closest_nodes() {
  return closest_nodes_.Add();
}
inline void FindResponse::add_closest_nodes(const ::std::string& value) {
  closest_nodes_.Add()->assign(value);
}
inline void FindResponse::add_closest_nodes(const char* value) {
  closest_nodes_.Add()->assign(value);
}
inline void FindResponse::set_closest_nodes(int index, const void* value, size_t size) {
  closest_nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void FindResponse::add_closest_nodes(const void* value, size_t size) {
  closest_nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated bytes values = 3;
inline int FindResponse::values_size() const {
  return values_.size();
}
inline void FindResponse::clear_values() {
  values_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindResponse::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindResponse::mutable_values() {
  return &values_;
}
inline const ::std::string& FindResponse::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* FindResponse::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void FindResponse::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void FindResponse::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline ::std::string* FindResponse::add_values() {
  return values_.Add();
}
inline void FindResponse::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void FindResponse::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void FindResponse::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void FindResponse::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes requester_ext_addr = 4;
inline bool FindResponse::has_requester_ext_addr() const {
  return _has_bit(3);
}
inline void FindResponse::clear_requester_ext_addr() {
  if (requester_ext_addr_ != &_default_requester_ext_addr_) {
    requester_ext_addr_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& FindResponse::requester_ext_addr() const {
  return *requester_ext_addr_;
}
inline void FindResponse::set_requester_ext_addr(const ::std::string& value) {
  _set_bit(3);
  if (requester_ext_addr_ == &_default_requester_ext_addr_) {
    requester_ext_addr_ = new ::std::string;
  }
  requester_ext_addr_->assign(value);
}
inline void FindResponse::set_requester_ext_addr(const char* value) {
  _set_bit(3);
  if (requester_ext_addr_ == &_default_requester_ext_addr_) {
    requester_ext_addr_ = new ::std::string;
  }
  requester_ext_addr_->assign(value);
}
inline void FindResponse::set_requester_ext_addr(const void* value, size_t size) {
  _set_bit(3);
  if (requester_ext_addr_ == &_default_requester_ext_addr_) {
    requester_ext_addr_ = new ::std::string;
  }
  requester_ext_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindResponse::mutable_requester_ext_addr() {
  _set_bit(3);
  if (requester_ext_addr_ == &_default_requester_ext_addr_) {
    requester_ext_addr_ = new ::std::string;
  }
  return requester_ext_addr_;
}

// optional bytes node_id = 5;
inline bool FindResponse::has_node_id() const {
  return _has_bit(4);
}
inline void FindResponse::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& FindResponse::node_id() const {
  return *node_id_;
}
inline void FindResponse::set_node_id(const ::std::string& value) {
  _set_bit(4);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void FindResponse::set_node_id(const char* value) {
  _set_bit(4);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void FindResponse::set_node_id(const void* value, size_t size) {
  _set_bit(4);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindResponse::mutable_node_id() {
  _set_bit(4);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// -------------------------------------------------------------------

// FindNodeResult

// required bytes result = 1;
inline bool FindNodeResult::has_result() const {
  return _has_bit(0);
}
inline void FindNodeResult::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FindNodeResult::result() const {
  return *result_;
}
inline void FindNodeResult::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void FindNodeResult::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void FindNodeResult::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodeResult::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes contact = 2;
inline bool FindNodeResult::has_contact() const {
  return _has_bit(1);
}
inline void FindNodeResult::clear_contact() {
  if (contact_ != &_default_contact_) {
    contact_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& FindNodeResult::contact() const {
  return *contact_;
}
inline void FindNodeResult::set_contact(const ::std::string& value) {
  _set_bit(1);
  if (contact_ == &_default_contact_) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void FindNodeResult::set_contact(const char* value) {
  _set_bit(1);
  if (contact_ == &_default_contact_) {
    contact_ = new ::std::string;
  }
  contact_->assign(value);
}
inline void FindNodeResult::set_contact(const void* value, size_t size) {
  _set_bit(1);
  if (contact_ == &_default_contact_) {
    contact_ = new ::std::string;
  }
  contact_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodeResult::mutable_contact() {
  _set_bit(1);
  if (contact_ == &_default_contact_) {
    contact_ = new ::std::string;
  }
  return contact_;
}

// optional bytes node_id = 3;
inline bool FindNodeResult::has_node_id() const {
  return _has_bit(2);
}
inline void FindNodeResult::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& FindNodeResult::node_id() const {
  return *node_id_;
}
inline void FindNodeResult::set_node_id(const ::std::string& value) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void FindNodeResult::set_node_id(const char* value) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void FindNodeResult::set_node_id(const void* value, size_t size) {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodeResult::mutable_node_id() {
  _set_bit(2);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// -------------------------------------------------------------------

// StoreRequest

// required bytes key = 1;
inline bool StoreRequest::has_key() const {
  return _has_bit(0);
}
inline void StoreRequest::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreRequest::key() const {
  return *key_;
}
inline void StoreRequest::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void StoreRequest::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void StoreRequest::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// required bytes value = 2;
inline bool StoreRequest::has_value() const {
  return _has_bit(1);
}
inline void StoreRequest::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreRequest::value() const {
  return *value_;
}
inline void StoreRequest::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StoreRequest::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StoreRequest::set_value(const void* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// required bytes public_key = 3;
inline bool StoreRequest::has_public_key() const {
  return _has_bit(2);
}
inline void StoreRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreRequest::public_key() const {
  return *public_key_;
}
inline void StoreRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 4;
inline bool StoreRequest::has_signed_public_key() const {
  return _has_bit(3);
}
inline void StoreRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 5;
inline bool StoreRequest::has_signed_request() const {
  return _has_bit(4);
}
inline void StoreRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreRequest::signed_request() const {
  return *signed_request_;
}
inline void StoreRequest::set_signed_request(const ::std::string& value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const char* value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_request() {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required .kad.ContactInfo sender_info = 6;
inline bool StoreRequest::has_sender_info() const {
  return _has_bit(5);
}
inline void StoreRequest::clear_sender_info() {
  if (sender_info_ != NULL) sender_info_->::kad::ContactInfo::Clear();
  _clear_bit(5);
}
inline const ::kad::ContactInfo& StoreRequest::sender_info() const {
  return sender_info_ != NULL ? *sender_info_ : *default_instance_->sender_info_;
}
inline ::kad::ContactInfo* StoreRequest::mutable_sender_info() {
  _set_bit(5);
  if (sender_info_ == NULL) sender_info_ = new ::kad::ContactInfo;
  return sender_info_;
}

// -------------------------------------------------------------------

// StoreResponse

// required bytes result = 1;
inline bool StoreResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreResponse::result() const {
  return *result_;
}
inline void StoreResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes node_id = 2;
inline bool StoreResponse::has_node_id() const {
  return _has_bit(1);
}
inline void StoreResponse::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreResponse::node_id() const {
  return *node_id_;
}
inline void StoreResponse::set_node_id(const ::std::string& value) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void StoreResponse::set_node_id(const char* value) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void StoreResponse::set_node_id(const void* value, size_t size) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreResponse::mutable_node_id() {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// -------------------------------------------------------------------

// DownlistRequest

// repeated bytes downlist = 1;
inline int DownlistRequest::downlist_size() const {
  return downlist_.size();
}
inline void DownlistRequest::clear_downlist() {
  downlist_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DownlistRequest::downlist() const {
  return downlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DownlistRequest::mutable_downlist() {
  return &downlist_;
}
inline const ::std::string& DownlistRequest::downlist(int index) const {
  return downlist_.Get(index);
}
inline ::std::string* DownlistRequest::mutable_downlist(int index) {
  return downlist_.Mutable(index);
}
inline void DownlistRequest::set_downlist(int index, const ::std::string& value) {
  downlist_.Mutable(index)->assign(value);
}
inline void DownlistRequest::set_downlist(int index, const char* value) {
  downlist_.Mutable(index)->assign(value);
}
inline ::std::string* DownlistRequest::add_downlist() {
  return downlist_.Add();
}
inline void DownlistRequest::add_downlist(const ::std::string& value) {
  downlist_.Add()->assign(value);
}
inline void DownlistRequest::add_downlist(const char* value) {
  downlist_.Add()->assign(value);
}
inline void DownlistRequest::set_downlist(int index, const void* value, size_t size) {
  downlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void DownlistRequest::add_downlist(const void* value, size_t size) {
  downlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// required .kad.ContactInfo sender_info = 2;
inline bool DownlistRequest::has_sender_info() const {
  return _has_bit(1);
}
inline void DownlistRequest::clear_sender_info() {
  if (sender_info_ != NULL) sender_info_->::kad::ContactInfo::Clear();
  _clear_bit(1);
}
inline const ::kad::ContactInfo& DownlistRequest::sender_info() const {
  return sender_info_ != NULL ? *sender_info_ : *default_instance_->sender_info_;
}
inline ::kad::ContactInfo* DownlistRequest::mutable_sender_info() {
  _set_bit(1);
  if (sender_info_ == NULL) sender_info_ = new ::kad::ContactInfo;
  return sender_info_;
}

// -------------------------------------------------------------------

// DownlistResponse

// required bytes result = 1;
inline bool DownlistResponse::has_result() const {
  return _has_bit(0);
}
inline void DownlistResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DownlistResponse::result() const {
  return *result_;
}
inline void DownlistResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void DownlistResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void DownlistResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownlistResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes node_id = 2;
inline bool DownlistResponse::has_node_id() const {
  return _has_bit(1);
}
inline void DownlistResponse::clear_node_id() {
  if (node_id_ != &_default_node_id_) {
    node_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DownlistResponse::node_id() const {
  return *node_id_;
}
inline void DownlistResponse::set_node_id(const ::std::string& value) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void DownlistResponse::set_node_id(const char* value) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void DownlistResponse::set_node_id(const void* value, size_t size) {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownlistResponse::mutable_node_id() {
  _set_bit(1);
  if (node_id_ == &_default_node_id_) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}

// -------------------------------------------------------------------

// BootstrapRequest

// required bytes newcomer_id = 1;
inline bool BootstrapRequest::has_newcomer_id() const {
  return _has_bit(0);
}
inline void BootstrapRequest::clear_newcomer_id() {
  if (newcomer_id_ != &_default_newcomer_id_) {
    newcomer_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BootstrapRequest::newcomer_id() const {
  return *newcomer_id_;
}
inline void BootstrapRequest::set_newcomer_id(const ::std::string& value) {
  _set_bit(0);
  if (newcomer_id_ == &_default_newcomer_id_) {
    newcomer_id_ = new ::std::string;
  }
  newcomer_id_->assign(value);
}
inline void BootstrapRequest::set_newcomer_id(const char* value) {
  _set_bit(0);
  if (newcomer_id_ == &_default_newcomer_id_) {
    newcomer_id_ = new ::std::string;
  }
  newcomer_id_->assign(value);
}
inline void BootstrapRequest::set_newcomer_id(const void* value, size_t size) {
  _set_bit(0);
  if (newcomer_id_ == &_default_newcomer_id_) {
    newcomer_id_ = new ::std::string;
  }
  newcomer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapRequest::mutable_newcomer_id() {
  _set_bit(0);
  if (newcomer_id_ == &_default_newcomer_id_) {
    newcomer_id_ = new ::std::string;
  }
  return newcomer_id_;
}

// required bytes newcomer_local_ip = 2;
inline bool BootstrapRequest::has_newcomer_local_ip() const {
  return _has_bit(1);
}
inline void BootstrapRequest::clear_newcomer_local_ip() {
  if (newcomer_local_ip_ != &_default_newcomer_local_ip_) {
    newcomer_local_ip_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BootstrapRequest::newcomer_local_ip() const {
  return *newcomer_local_ip_;
}
inline void BootstrapRequest::set_newcomer_local_ip(const ::std::string& value) {
  _set_bit(1);
  if (newcomer_local_ip_ == &_default_newcomer_local_ip_) {
    newcomer_local_ip_ = new ::std::string;
  }
  newcomer_local_ip_->assign(value);
}
inline void BootstrapRequest::set_newcomer_local_ip(const char* value) {
  _set_bit(1);
  if (newcomer_local_ip_ == &_default_newcomer_local_ip_) {
    newcomer_local_ip_ = new ::std::string;
  }
  newcomer_local_ip_->assign(value);
}
inline void BootstrapRequest::set_newcomer_local_ip(const void* value, size_t size) {
  _set_bit(1);
  if (newcomer_local_ip_ == &_default_newcomer_local_ip_) {
    newcomer_local_ip_ = new ::std::string;
  }
  newcomer_local_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapRequest::mutable_newcomer_local_ip() {
  _set_bit(1);
  if (newcomer_local_ip_ == &_default_newcomer_local_ip_) {
    newcomer_local_ip_ = new ::std::string;
  }
  return newcomer_local_ip_;
}

// required int32 newcomer_local_port = 3;
inline bool BootstrapRequest::has_newcomer_local_port() const {
  return _has_bit(2);
}
inline void BootstrapRequest::clear_newcomer_local_port() {
  newcomer_local_port_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 BootstrapRequest::newcomer_local_port() const {
  return newcomer_local_port_;
}
inline void BootstrapRequest::set_newcomer_local_port(::google::protobuf::int32 value) {
  _set_bit(2);
  newcomer_local_port_ = value;
}

// optional bytes newcomer_ext_ip = 4;
inline bool BootstrapRequest::has_newcomer_ext_ip() const {
  return _has_bit(3);
}
inline void BootstrapRequest::clear_newcomer_ext_ip() {
  if (newcomer_ext_ip_ != &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BootstrapRequest::newcomer_ext_ip() const {
  return *newcomer_ext_ip_;
}
inline void BootstrapRequest::set_newcomer_ext_ip(const ::std::string& value) {
  _set_bit(3);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(value);
}
inline void BootstrapRequest::set_newcomer_ext_ip(const char* value) {
  _set_bit(3);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(value);
}
inline void BootstrapRequest::set_newcomer_ext_ip(const void* value, size_t size) {
  _set_bit(3);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapRequest::mutable_newcomer_ext_ip() {
  _set_bit(3);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  return newcomer_ext_ip_;
}

// optional int32 newcomer_ext_port = 5;
inline bool BootstrapRequest::has_newcomer_ext_port() const {
  return _has_bit(4);
}
inline void BootstrapRequest::clear_newcomer_ext_port() {
  newcomer_ext_port_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 BootstrapRequest::newcomer_ext_port() const {
  return newcomer_ext_port_;
}
inline void BootstrapRequest::set_newcomer_ext_port(::google::protobuf::int32 value) {
  _set_bit(4);
  newcomer_ext_port_ = value;
}

// -------------------------------------------------------------------

// BootstrapResponse

// required bytes result = 1;
inline bool BootstrapResponse::has_result() const {
  return _has_bit(0);
}
inline void BootstrapResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BootstrapResponse::result() const {
  return *result_;
}
inline void BootstrapResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void BootstrapResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void BootstrapResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes bootstrap_id = 2;
inline bool BootstrapResponse::has_bootstrap_id() const {
  return _has_bit(1);
}
inline void BootstrapResponse::clear_bootstrap_id() {
  if (bootstrap_id_ != &_default_bootstrap_id_) {
    bootstrap_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BootstrapResponse::bootstrap_id() const {
  return *bootstrap_id_;
}
inline void BootstrapResponse::set_bootstrap_id(const ::std::string& value) {
  _set_bit(1);
  if (bootstrap_id_ == &_default_bootstrap_id_) {
    bootstrap_id_ = new ::std::string;
  }
  bootstrap_id_->assign(value);
}
inline void BootstrapResponse::set_bootstrap_id(const char* value) {
  _set_bit(1);
  if (bootstrap_id_ == &_default_bootstrap_id_) {
    bootstrap_id_ = new ::std::string;
  }
  bootstrap_id_->assign(value);
}
inline void BootstrapResponse::set_bootstrap_id(const void* value, size_t size) {
  _set_bit(1);
  if (bootstrap_id_ == &_default_bootstrap_id_) {
    bootstrap_id_ = new ::std::string;
  }
  bootstrap_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapResponse::mutable_bootstrap_id() {
  _set_bit(1);
  if (bootstrap_id_ == &_default_bootstrap_id_) {
    bootstrap_id_ = new ::std::string;
  }
  return bootstrap_id_;
}

// optional bytes newcomer_ext_ip = 3;
inline bool BootstrapResponse::has_newcomer_ext_ip() const {
  return _has_bit(2);
}
inline void BootstrapResponse::clear_newcomer_ext_ip() {
  if (newcomer_ext_ip_ != &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BootstrapResponse::newcomer_ext_ip() const {
  return *newcomer_ext_ip_;
}
inline void BootstrapResponse::set_newcomer_ext_ip(const ::std::string& value) {
  _set_bit(2);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(value);
}
inline void BootstrapResponse::set_newcomer_ext_ip(const char* value) {
  _set_bit(2);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(value);
}
inline void BootstrapResponse::set_newcomer_ext_ip(const void* value, size_t size) {
  _set_bit(2);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  newcomer_ext_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootstrapResponse::mutable_newcomer_ext_ip() {
  _set_bit(2);
  if (newcomer_ext_ip_ == &_default_newcomer_ext_ip_) {
    newcomer_ext_ip_ = new ::std::string;
  }
  return newcomer_ext_ip_;
}

// optional int32 newcomer_ext_port = 4;
inline bool BootstrapResponse::has_newcomer_ext_port() const {
  return _has_bit(3);
}
inline void BootstrapResponse::clear_newcomer_ext_port() {
  newcomer_ext_port_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 BootstrapResponse::newcomer_ext_port() const {
  return newcomer_ext_port_;
}
inline void BootstrapResponse::set_newcomer_ext_port(::google::protobuf::int32 value) {
  _set_bit(3);
  newcomer_ext_port_ = value;
}

// optional int32 nat_type = 5;
inline bool BootstrapResponse::has_nat_type() const {
  return _has_bit(4);
}
inline void BootstrapResponse::clear_nat_type() {
  nat_type_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 BootstrapResponse::nat_type() const {
  return nat_type_;
}
inline void BootstrapResponse::set_nat_type(::google::protobuf::int32 value) {
  _set_bit(4);
  nat_type_ = value;
}

// -------------------------------------------------------------------

// NatDetectionRequest

// required bytes newcomer = 1;
inline bool NatDetectionRequest::has_newcomer() const {
  return _has_bit(0);
}
inline void NatDetectionRequest::clear_newcomer() {
  if (newcomer_ != &_default_newcomer_) {
    newcomer_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& NatDetectionRequest::newcomer() const {
  return *newcomer_;
}
inline void NatDetectionRequest::set_newcomer(const ::std::string& value) {
  _set_bit(0);
  if (newcomer_ == &_default_newcomer_) {
    newcomer_ = new ::std::string;
  }
  newcomer_->assign(value);
}
inline void NatDetectionRequest::set_newcomer(const char* value) {
  _set_bit(0);
  if (newcomer_ == &_default_newcomer_) {
    newcomer_ = new ::std::string;
  }
  newcomer_->assign(value);
}
inline void NatDetectionRequest::set_newcomer(const void* value, size_t size) {
  _set_bit(0);
  if (newcomer_ == &_default_newcomer_) {
    newcomer_ = new ::std::string;
  }
  newcomer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionRequest::mutable_newcomer() {
  _set_bit(0);
  if (newcomer_ == &_default_newcomer_) {
    newcomer_ = new ::std::string;
  }
  return newcomer_;
}

// required bytes bootstrap_node = 2;
inline bool NatDetectionRequest::has_bootstrap_node() const {
  return _has_bit(1);
}
inline void NatDetectionRequest::clear_bootstrap_node() {
  if (bootstrap_node_ != &_default_bootstrap_node_) {
    bootstrap_node_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& NatDetectionRequest::bootstrap_node() const {
  return *bootstrap_node_;
}
inline void NatDetectionRequest::set_bootstrap_node(const ::std::string& value) {
  _set_bit(1);
  if (bootstrap_node_ == &_default_bootstrap_node_) {
    bootstrap_node_ = new ::std::string;
  }
  bootstrap_node_->assign(value);
}
inline void NatDetectionRequest::set_bootstrap_node(const char* value) {
  _set_bit(1);
  if (bootstrap_node_ == &_default_bootstrap_node_) {
    bootstrap_node_ = new ::std::string;
  }
  bootstrap_node_->assign(value);
}
inline void NatDetectionRequest::set_bootstrap_node(const void* value, size_t size) {
  _set_bit(1);
  if (bootstrap_node_ == &_default_bootstrap_node_) {
    bootstrap_node_ = new ::std::string;
  }
  bootstrap_node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionRequest::mutable_bootstrap_node() {
  _set_bit(1);
  if (bootstrap_node_ == &_default_bootstrap_node_) {
    bootstrap_node_ = new ::std::string;
  }
  return bootstrap_node_;
}

// required int32 type = 3;
inline bool NatDetectionRequest::has_type() const {
  return _has_bit(2);
}
inline void NatDetectionRequest::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 NatDetectionRequest::type() const {
  return type_;
}
inline void NatDetectionRequest::set_type(::google::protobuf::int32 value) {
  _set_bit(2);
  type_ = value;
}

// required bytes sender_id = 4;
inline bool NatDetectionRequest::has_sender_id() const {
  return _has_bit(3);
}
inline void NatDetectionRequest::clear_sender_id() {
  if (sender_id_ != &_default_sender_id_) {
    sender_id_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& NatDetectionRequest::sender_id() const {
  return *sender_id_;
}
inline void NatDetectionRequest::set_sender_id(const ::std::string& value) {
  _set_bit(3);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void NatDetectionRequest::set_sender_id(const char* value) {
  _set_bit(3);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void NatDetectionRequest::set_sender_id(const void* value, size_t size) {
  _set_bit(3);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionRequest::mutable_sender_id() {
  _set_bit(3);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  return sender_id_;
}

// -------------------------------------------------------------------

// NatDetectionResponse

// required bytes result = 1;
inline bool NatDetectionResponse::has_result() const {
  return _has_bit(0);
}
inline void NatDetectionResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& NatDetectionResponse::result() const {
  return *result_;
}
inline void NatDetectionResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void NatDetectionResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void NatDetectionResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// -------------------------------------------------------------------

// NatDetectionPingRequest

// required bytes ping = 1;
inline bool NatDetectionPingRequest::has_ping() const {
  return _has_bit(0);
}
inline void NatDetectionPingRequest::clear_ping() {
  if (ping_ != &_default_ping_) {
    ping_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& NatDetectionPingRequest::ping() const {
  return *ping_;
}
inline void NatDetectionPingRequest::set_ping(const ::std::string& value) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void NatDetectionPingRequest::set_ping(const char* value) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(value);
}
inline void NatDetectionPingRequest::set_ping(const void* value, size_t size) {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  ping_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionPingRequest::mutable_ping() {
  _set_bit(0);
  if (ping_ == &_default_ping_) {
    ping_ = new ::std::string;
  }
  return ping_;
}

// required .kad.ContactInfo sender_info = 2;
inline bool NatDetectionPingRequest::has_sender_info() const {
  return _has_bit(1);
}
inline void NatDetectionPingRequest::clear_sender_info() {
  if (sender_info_ != NULL) sender_info_->::kad::ContactInfo::Clear();
  _clear_bit(1);
}
inline const ::kad::ContactInfo& NatDetectionPingRequest::sender_info() const {
  return sender_info_ != NULL ? *sender_info_ : *default_instance_->sender_info_;
}
inline ::kad::ContactInfo* NatDetectionPingRequest::mutable_sender_info() {
  _set_bit(1);
  if (sender_info_ == NULL) sender_info_ = new ::kad::ContactInfo;
  return sender_info_;
}

// -------------------------------------------------------------------

// NatDetectionPingResponse

// required bytes result = 1;
inline bool NatDetectionPingResponse::has_result() const {
  return _has_bit(0);
}
inline void NatDetectionPingResponse::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& NatDetectionPingResponse::result() const {
  return *result_;
}
inline void NatDetectionPingResponse::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void NatDetectionPingResponse::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void NatDetectionPingResponse::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionPingResponse::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes echo = 2;
inline bool NatDetectionPingResponse::has_echo() const {
  return _has_bit(1);
}
inline void NatDetectionPingResponse::clear_echo() {
  if (echo_ != &_default_echo_) {
    echo_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& NatDetectionPingResponse::echo() const {
  return *echo_;
}
inline void NatDetectionPingResponse::set_echo(const ::std::string& value) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(value);
}
inline void NatDetectionPingResponse::set_echo(const char* value) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(value);
}
inline void NatDetectionPingResponse::set_echo(const void* value, size_t size) {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  echo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NatDetectionPingResponse::mutable_echo() {
  _set_bit(1);
  if (echo_ == &_default_echo_) {
    echo_ = new ::std::string;
  }
  return echo_;
}


}  // namespace kad
#endif  // PROTOBUF_kademlia_5fservice_5fmessages_2eproto__INCLUDED
