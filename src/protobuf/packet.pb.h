// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_packet_2eproto__INCLUDED
#define PROTOBUF_packet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace packethandler {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_packet_2eproto();
void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class GenericPacket;
class BufferPacketInfo;
class BufferPacketMessage;
class BufferPacket;
class ValidatedBufferPacketMessage;
class ContactInfo;
class ContactNotification;
class InstantFileNotification;
class PrivateShareNotification;
class InstantMessage;
class StoreMessagesResult;
class CreateMSIDResult;

enum MessageType {
  ADD_CONTACT_RQST = 1,
  INSTANT_MSG = 2,
  STATUS_CHECK = 3
};
const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = ADD_CONTACT_RQST;
const MessageType MessageType_MAX = STATUS_CHECK;

// ===================================================================

class GenericPacket : public ::google::protobuf::Message {
 public:
  GenericPacket();
  virtual ~GenericPacket();
  
  GenericPacket(const GenericPacket& from);
  
  inline GenericPacket& operator=(const GenericPacket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericPacket& default_instance();
  void Swap(GenericPacket* other);
  
  // implements Message ----------------------------------------------
  
  GenericPacket* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GenericPacket* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacketInfo : public ::google::protobuf::Message {
 public:
  BufferPacketInfo();
  virtual ~BufferPacketInfo();
  
  BufferPacketInfo(const BufferPacketInfo& from);
  
  inline BufferPacketInfo& operator=(const BufferPacketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacketInfo& default_instance();
  void Swap(BufferPacketInfo* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacketInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const void* value, size_t size);
  inline ::std::string* mutable_owner();
  
  // required bytes ownerPublicKey = 2;
  inline bool has_ownerpublickey() const;
  inline void clear_ownerpublickey();
  inline const ::std::string& ownerpublickey() const;
  inline void set_ownerpublickey(const ::std::string& value);
  inline void set_ownerpublickey(const char* value);
  inline void set_ownerpublickey(const void* value, size_t size);
  inline ::std::string* mutable_ownerpublickey();
  
  // repeated bytes users = 3;
  inline int users_size() const;
  inline void clear_users();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();
  inline const ::std::string& users(int index) const;
  inline ::std::string* mutable_users(int index);
  inline void set_users(int index, const ::std::string& value);
  inline void set_users(int index, const char* value);
  inline ::std::string* add_users();
  inline void add_users(const ::std::string& value);
  inline void add_users(const char* value);
  inline void set_users(int index, const void* value, size_t size);
  inline void add_users(const void* value, size_t size);
  
  // optional int32 online = 4;
  inline bool has_online() const;
  inline void clear_online();
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* owner_;
  static const ::std::string _default_owner_;
  ::std::string* ownerpublickey_;
  static const ::std::string _default_ownerpublickey_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  ::google::protobuf::int32 online_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacketInfo* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacketMessage : public ::google::protobuf::Message {
 public:
  BufferPacketMessage();
  virtual ~BufferPacketMessage();
  
  BufferPacketMessage(const BufferPacketMessage& from);
  
  inline BufferPacketMessage& operator=(const BufferPacketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacketMessage& default_instance();
  void Swap(BufferPacketMessage* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacketMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes sender_id = 1;
  inline bool has_sender_id() const;
  inline void clear_sender_id();
  inline const ::std::string& sender_id() const;
  inline void set_sender_id(const ::std::string& value);
  inline void set_sender_id(const char* value);
  inline void set_sender_id(const void* value, size_t size);
  inline ::std::string* mutable_sender_id();
  
  // optional bytes sender_public_key = 2;
  inline bool has_sender_public_key() const;
  inline void clear_sender_public_key();
  inline const ::std::string& sender_public_key() const;
  inline void set_sender_public_key(const ::std::string& value);
  inline void set_sender_public_key(const char* value);
  inline void set_sender_public_key(const void* value, size_t size);
  inline ::std::string* mutable_sender_public_key();
  
  // required bytes RSAenc_key = 3;
  inline bool has_rsaenc_key() const;
  inline void clear_rsaenc_key();
  inline const ::std::string& rsaenc_key() const;
  inline void set_rsaenc_key(const ::std::string& value);
  inline void set_rsaenc_key(const char* value);
  inline void set_rsaenc_key(const void* value, size_t size);
  inline ::std::string* mutable_rsaenc_key();
  
  // required bytes AESenc_message = 4;
  inline bool has_aesenc_message() const;
  inline void clear_aesenc_message();
  inline const ::std::string& aesenc_message() const;
  inline void set_aesenc_message(const ::std::string& value);
  inline void set_aesenc_message(const char* value);
  inline void set_aesenc_message(const void* value, size_t size);
  inline ::std::string* mutable_aesenc_message();
  
  // required .packethandler.MessageType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  inline packethandler::MessageType type() const;
  inline void set_type(packethandler::MessageType value);
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_id_;
  static const ::std::string _default_sender_id_;
  ::std::string* sender_public_key_;
  static const ::std::string _default_sender_public_key_;
  ::std::string* rsaenc_key_;
  static const ::std::string _default_rsaenc_key_;
  ::std::string* aesenc_message_;
  static const ::std::string _default_aesenc_message_;
  int type_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacketMessage* default_instance_;
};
// -------------------------------------------------------------------

class BufferPacket : public ::google::protobuf::Message {
 public:
  BufferPacket();
  virtual ~BufferPacket();
  
  BufferPacket(const BufferPacket& from);
  
  inline BufferPacket& operator=(const BufferPacket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferPacket& default_instance();
  void Swap(BufferPacket* other);
  
  // implements Message ----------------------------------------------
  
  BufferPacket* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .packethandler.GenericPacket owner_info = 1;
  inline int owner_info_size() const;
  inline void clear_owner_info();
  inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >& owner_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >* mutable_owner_info();
  inline const ::packethandler::GenericPacket& owner_info(int index) const;
  inline ::packethandler::GenericPacket* mutable_owner_info(int index);
  inline ::packethandler::GenericPacket* add_owner_info();
  
  // repeated .packethandler.GenericPacket messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >& messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >* mutable_messages();
  inline const ::packethandler::GenericPacket& messages(int index) const;
  inline ::packethandler::GenericPacket* mutable_messages(int index);
  inline ::packethandler::GenericPacket* add_messages();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket > owner_info_;
  ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket > messages_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BufferPacket* default_instance_;
};
// -------------------------------------------------------------------

class ValidatedBufferPacketMessage : public ::google::protobuf::Message {
 public:
  ValidatedBufferPacketMessage();
  virtual ~ValidatedBufferPacketMessage();
  
  ValidatedBufferPacketMessage(const ValidatedBufferPacketMessage& from);
  
  inline ValidatedBufferPacketMessage& operator=(const ValidatedBufferPacketMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidatedBufferPacketMessage& default_instance();
  void Swap(ValidatedBufferPacketMessage* other);
  
  // implements Message ----------------------------------------------
  
  ValidatedBufferPacketMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const void* value, size_t size);
  inline ::std::string* mutable_sender();
  
  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  
  // required bytes index = 3;
  inline bool has_index() const;
  inline void clear_index();
  inline const ::std::string& index() const;
  inline void set_index(const ::std::string& value);
  inline void set_index(const char* value);
  inline void set_index(const void* value, size_t size);
  inline ::std::string* mutable_index();
  
  // required .packethandler.MessageType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  inline packethandler::MessageType type() const;
  inline void set_type(packethandler::MessageType value);
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_;
  static const ::std::string _default_sender_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  ::std::string* index_;
  static const ::std::string _default_index_;
  int type_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidatedBufferPacketMessage* default_instance_;
};
// -------------------------------------------------------------------

class ContactInfo : public ::google::protobuf::Message {
 public:
  ContactInfo();
  virtual ~ContactInfo();
  
  ContactInfo(const ContactInfo& from);
  
  inline ContactInfo& operator=(const ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfo& default_instance();
  void Swap(ContactInfo* other);
  
  // implements Message ----------------------------------------------
  
  ContactInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional bytes birthday = 2;
  inline bool has_birthday() const;
  inline void clear_birthday();
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const void* value, size_t size);
  inline ::std::string* mutable_birthday();
  
  // optional bytes office_number = 3;
  inline bool has_office_number() const;
  inline void clear_office_number();
  inline const ::std::string& office_number() const;
  inline void set_office_number(const ::std::string& value);
  inline void set_office_number(const char* value);
  inline void set_office_number(const void* value, size_t size);
  inline ::std::string* mutable_office_number();
  
  // optional bytes gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const void* value, size_t size);
  inline ::std::string* mutable_gender();
  
  // optional int32 country = 5;
  inline bool has_country() const;
  inline void clear_country();
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);
  
  // optional bytes city = 6;
  inline bool has_city() const;
  inline void clear_city();
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const void* value, size_t size);
  inline ::std::string* mutable_city();
  
  // optional int32 language = 7;
  inline bool has_language() const;
  inline void clear_language();
  inline ::google::protobuf::int32 language() const;
  inline void set_language(::google::protobuf::int32 value);
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* birthday_;
  static const ::std::string _default_birthday_;
  ::std::string* office_number_;
  static const ::std::string _default_office_number_;
  ::std::string* gender_;
  static const ::std::string _default_gender_;
  ::google::protobuf::int32 country_;
  ::std::string* city_;
  static const ::std::string _default_city_;
  ::google::protobuf::int32 language_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContactNotification : public ::google::protobuf::Message {
 public:
  ContactNotification();
  virtual ~ContactNotification();
  
  ContactNotification(const ContactNotification& from);
  
  inline ContactNotification& operator=(const ContactNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactNotification& default_instance();
  void Swap(ContactNotification* other);
  
  // implements Message ----------------------------------------------
  
  ContactNotification* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // optional .packethandler.ContactInfo contact = 2;
  inline bool has_contact() const;
  inline void clear_contact();
  inline const ::packethandler::ContactInfo& contact() const;
  inline ::packethandler::ContactInfo* mutable_contact();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 action_;
  ::packethandler::ContactInfo* contact_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ContactNotification* default_instance_;
};
// -------------------------------------------------------------------

class InstantFileNotification : public ::google::protobuf::Message {
 public:
  InstantFileNotification();
  virtual ~InstantFileNotification();
  
  InstantFileNotification(const InstantFileNotification& from);
  
  inline InstantFileNotification& operator=(const InstantFileNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstantFileNotification& default_instance();
  void Swap(InstantFileNotification* other);
  
  // implements Message ----------------------------------------------
  
  InstantFileNotification* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes ser_mdm = 1;
  inline bool has_ser_mdm() const;
  inline void clear_ser_mdm();
  inline const ::std::string& ser_mdm() const;
  inline void set_ser_mdm(const ::std::string& value);
  inline void set_ser_mdm(const char* value);
  inline void set_ser_mdm(const void* value, size_t size);
  inline ::std::string* mutable_ser_mdm();
  
  // required bytes ser_dm = 2;
  inline bool has_ser_dm() const;
  inline void clear_ser_dm();
  inline const ::std::string& ser_dm() const;
  inline void set_ser_dm(const ::std::string& value);
  inline void set_ser_dm(const char* value);
  inline void set_ser_dm(const void* value, size_t size);
  inline ::std::string* mutable_ser_dm();
  
  // required bytes filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const void* value, size_t size);
  inline ::std::string* mutable_filename();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ser_mdm_;
  static const ::std::string _default_ser_mdm_;
  ::std::string* ser_dm_;
  static const ::std::string _default_ser_dm_;
  ::std::string* filename_;
  static const ::std::string _default_filename_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InstantFileNotification* default_instance_;
};
// -------------------------------------------------------------------

class PrivateShareNotification : public ::google::protobuf::Message {
 public:
  PrivateShareNotification();
  virtual ~PrivateShareNotification();
  
  PrivateShareNotification(const PrivateShareNotification& from);
  
  inline PrivateShareNotification& operator=(const PrivateShareNotification& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateShareNotification& default_instance();
  void Swap(PrivateShareNotification* other);
  
  // implements Message ----------------------------------------------
  
  PrivateShareNotification* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required bytes msid = 2;
  inline bool has_msid() const;
  inline void clear_msid();
  inline const ::std::string& msid() const;
  inline void set_msid(const ::std::string& value);
  inline void set_msid(const char* value);
  inline void set_msid(const void* value, size_t size);
  inline ::std::string* mutable_msid();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes private_key = 4;
  inline bool has_private_key() const;
  inline void clear_private_key();
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // repeated bytes admins = 5;
  inline int admins_size() const;
  inline void clear_admins();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& admins() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_admins();
  inline const ::std::string& admins(int index) const;
  inline ::std::string* mutable_admins(int index);
  inline void set_admins(int index, const ::std::string& value);
  inline void set_admins(int index, const char* value);
  inline ::std::string* add_admins();
  inline void add_admins(const ::std::string& value);
  inline void add_admins(const char* value);
  inline void set_admins(int index, const void* value, size_t size);
  inline void add_admins(const void* value, size_t size);
  
  // repeated bytes readonlys = 6;
  inline int readonlys_size() const;
  inline void clear_readonlys();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& readonlys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_readonlys();
  inline const ::std::string& readonlys(int index) const;
  inline ::std::string* mutable_readonlys(int index);
  inline void set_readonlys(int index, const ::std::string& value);
  inline void set_readonlys(int index, const char* value);
  inline ::std::string* add_readonlys();
  inline void add_readonlys(const ::std::string& value);
  inline void add_readonlys(const char* value);
  inline void set_readonlys(int index, const void* value, size_t size);
  inline void add_readonlys(const void* value, size_t size);
  
  // required bytes dir_db_key = 7;
  inline bool has_dir_db_key() const;
  inline void clear_dir_db_key();
  inline const ::std::string& dir_db_key() const;
  inline void set_dir_db_key(const ::std::string& value);
  inline void set_dir_db_key(const char* value);
  inline void set_dir_db_key(const void* value, size_t size);
  inline ::std::string* mutable_dir_db_key();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* msid_;
  static const ::std::string _default_msid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> admins_;
  ::google::protobuf::RepeatedPtrField< ::std::string> readonlys_;
  ::std::string* dir_db_key_;
  static const ::std::string _default_dir_db_key_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PrivateShareNotification* default_instance_;
};
// -------------------------------------------------------------------

class InstantMessage : public ::google::protobuf::Message {
 public:
  InstantMessage();
  virtual ~InstantMessage();
  
  InstantMessage(const InstantMessage& from);
  
  inline InstantMessage& operator=(const InstantMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstantMessage& default_instance();
  void Swap(InstantMessage* other);
  
  // implements Message ----------------------------------------------
  
  InstantMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const void* value, size_t size);
  inline ::std::string* mutable_sender();
  
  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  
  // required int32 date = 3;
  inline bool has_date() const;
  inline void clear_date();
  inline ::google::protobuf::int32 date() const;
  inline void set_date(::google::protobuf::int32 value);
  
  // optional .packethandler.ContactNotification contact_notification = 4;
  inline bool has_contact_notification() const;
  inline void clear_contact_notification();
  inline const ::packethandler::ContactNotification& contact_notification() const;
  inline ::packethandler::ContactNotification* mutable_contact_notification();
  
  // optional .packethandler.InstantFileNotification instantfile_notification = 5;
  inline bool has_instantfile_notification() const;
  inline void clear_instantfile_notification();
  inline const ::packethandler::InstantFileNotification& instantfile_notification() const;
  inline ::packethandler::InstantFileNotification* mutable_instantfile_notification();
  
  // optional .packethandler.PrivateShareNotification privateshare_notification = 6;
  inline bool has_privateshare_notification() const;
  inline void clear_privateshare_notification();
  inline const ::packethandler::PrivateShareNotification& privateshare_notification() const;
  inline ::packethandler::PrivateShareNotification* mutable_privateshare_notification();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sender_;
  static const ::std::string _default_sender_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  ::google::protobuf::int32 date_;
  ::packethandler::ContactNotification* contact_notification_;
  ::packethandler::InstantFileNotification* instantfile_notification_;
  ::packethandler::PrivateShareNotification* privateshare_notification_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static InstantMessage* default_instance_;
};
// -------------------------------------------------------------------

class StoreMessagesResult : public ::google::protobuf::Message {
 public:
  StoreMessagesResult();
  virtual ~StoreMessagesResult();
  
  StoreMessagesResult(const StoreMessagesResult& from);
  
  inline StoreMessagesResult& operator=(const StoreMessagesResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreMessagesResult& default_instance();
  void Swap(StoreMessagesResult* other);
  
  // implements Message ----------------------------------------------
  
  StoreMessagesResult* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // required int32 stored_msgs = 2;
  inline bool has_stored_msgs() const;
  inline void clear_stored_msgs();
  inline ::google::protobuf::int32 stored_msgs() const;
  inline void set_stored_msgs(::google::protobuf::int32 value);
  
  // repeated bytes failed = 3;
  inline int failed_size() const;
  inline void clear_failed();
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& failed() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_failed();
  inline const ::std::string& failed(int index) const;
  inline ::std::string* mutable_failed(int index);
  inline void set_failed(int index, const ::std::string& value);
  inline void set_failed(int index, const char* value);
  inline ::std::string* add_failed();
  inline void add_failed(const ::std::string& value);
  inline void add_failed(const char* value);
  inline void set_failed(int index, const void* value, size_t size);
  inline void add_failed(const void* value, size_t size);
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::google::protobuf::int32 stored_msgs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> failed_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreMessagesResult* default_instance_;
};
// -------------------------------------------------------------------

class CreateMSIDResult : public ::google::protobuf::Message {
 public:
  CreateMSIDResult();
  virtual ~CreateMSIDResult();
  
  CreateMSIDResult(const CreateMSIDResult& from);
  
  inline CreateMSIDResult& operator=(const CreateMSIDResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMSIDResult& default_instance();
  void Swap(CreateMSIDResult* other);
  
  // implements Message ----------------------------------------------
  
  CreateMSIDResult* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes result = 1;
  inline bool has_result() const;
  inline void clear_result();
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  
  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional bytes private_key = 3;
  inline bool has_private_key() const;
  inline void clear_private_key();
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // optional bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // nalga de camello -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* result_;
  static const ::std::string _default_result_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  friend void protobuf_BuildDesc_packet_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CreateMSIDResult* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// GenericPacket

// required bytes data = 1;
inline bool GenericPacket::has_data() const {
  return _has_bit(0);
}
inline void GenericPacket::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GenericPacket::data() const {
  return *data_;
}
inline void GenericPacket::set_data(const ::std::string& value) {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GenericPacket::set_data(const char* value) {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void GenericPacket::set_data(const void* value, size_t size) {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericPacket::mutable_data() {
  _set_bit(0);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes signature = 2;
inline bool GenericPacket::has_signature() const {
  return _has_bit(1);
}
inline void GenericPacket::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GenericPacket::signature() const {
  return *signature_;
}
inline void GenericPacket::set_signature(const ::std::string& value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void GenericPacket::set_signature(const char* value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void GenericPacket::set_signature(const void* value, size_t size) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GenericPacket::mutable_signature() {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// -------------------------------------------------------------------

// BufferPacketInfo

// required bytes owner = 1;
inline bool BufferPacketInfo::has_owner() const {
  return _has_bit(0);
}
inline void BufferPacketInfo::clear_owner() {
  if (owner_ != &_default_owner_) {
    owner_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BufferPacketInfo::owner() const {
  return *owner_;
}
inline void BufferPacketInfo::set_owner(const ::std::string& value) {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void BufferPacketInfo::set_owner(const char* value) {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
}
inline void BufferPacketInfo::set_owner(const void* value, size_t size) {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketInfo::mutable_owner() {
  _set_bit(0);
  if (owner_ == &_default_owner_) {
    owner_ = new ::std::string;
  }
  return owner_;
}

// required bytes ownerPublicKey = 2;
inline bool BufferPacketInfo::has_ownerpublickey() const {
  return _has_bit(1);
}
inline void BufferPacketInfo::clear_ownerpublickey() {
  if (ownerpublickey_ != &_default_ownerpublickey_) {
    ownerpublickey_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BufferPacketInfo::ownerpublickey() const {
  return *ownerpublickey_;
}
inline void BufferPacketInfo::set_ownerpublickey(const ::std::string& value) {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  ownerpublickey_->assign(value);
}
inline void BufferPacketInfo::set_ownerpublickey(const char* value) {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  ownerpublickey_->assign(value);
}
inline void BufferPacketInfo::set_ownerpublickey(const void* value, size_t size) {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  ownerpublickey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketInfo::mutable_ownerpublickey() {
  _set_bit(1);
  if (ownerpublickey_ == &_default_ownerpublickey_) {
    ownerpublickey_ = new ::std::string;
  }
  return ownerpublickey_;
}

// repeated bytes users = 3;
inline int BufferPacketInfo::users_size() const {
  return users_.size();
}
inline void BufferPacketInfo::clear_users() {
  users_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BufferPacketInfo::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BufferPacketInfo::mutable_users() {
  return &users_;
}
inline const ::std::string& BufferPacketInfo::users(int index) const {
  return users_.Get(index);
}
inline ::std::string* BufferPacketInfo::mutable_users(int index) {
  return users_.Mutable(index);
}
inline void BufferPacketInfo::set_users(int index, const ::std::string& value) {
  users_.Mutable(index)->assign(value);
}
inline void BufferPacketInfo::set_users(int index, const char* value) {
  users_.Mutable(index)->assign(value);
}
inline ::std::string* BufferPacketInfo::add_users() {
  return users_.Add();
}
inline void BufferPacketInfo::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
}
inline void BufferPacketInfo::add_users(const char* value) {
  users_.Add()->assign(value);
}
inline void BufferPacketInfo::set_users(int index, const void* value, size_t size) {
  users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void BufferPacketInfo::add_users(const void* value, size_t size) {
  users_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional int32 online = 4;
inline bool BufferPacketInfo::has_online() const {
  return _has_bit(3);
}
inline void BufferPacketInfo::clear_online() {
  online_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 BufferPacketInfo::online() const {
  return online_;
}
inline void BufferPacketInfo::set_online(::google::protobuf::int32 value) {
  _set_bit(3);
  online_ = value;
}

// -------------------------------------------------------------------

// BufferPacketMessage

// required bytes sender_id = 1;
inline bool BufferPacketMessage::has_sender_id() const {
  return _has_bit(0);
}
inline void BufferPacketMessage::clear_sender_id() {
  if (sender_id_ != &_default_sender_id_) {
    sender_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BufferPacketMessage::sender_id() const {
  return *sender_id_;
}
inline void BufferPacketMessage::set_sender_id(const ::std::string& value) {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void BufferPacketMessage::set_sender_id(const char* value) {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void BufferPacketMessage::set_sender_id(const void* value, size_t size) {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketMessage::mutable_sender_id() {
  _set_bit(0);
  if (sender_id_ == &_default_sender_id_) {
    sender_id_ = new ::std::string;
  }
  return sender_id_;
}

// optional bytes sender_public_key = 2;
inline bool BufferPacketMessage::has_sender_public_key() const {
  return _has_bit(1);
}
inline void BufferPacketMessage::clear_sender_public_key() {
  if (sender_public_key_ != &_default_sender_public_key_) {
    sender_public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& BufferPacketMessage::sender_public_key() const {
  return *sender_public_key_;
}
inline void BufferPacketMessage::set_sender_public_key(const ::std::string& value) {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  sender_public_key_->assign(value);
}
inline void BufferPacketMessage::set_sender_public_key(const char* value) {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  sender_public_key_->assign(value);
}
inline void BufferPacketMessage::set_sender_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  sender_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketMessage::mutable_sender_public_key() {
  _set_bit(1);
  if (sender_public_key_ == &_default_sender_public_key_) {
    sender_public_key_ = new ::std::string;
  }
  return sender_public_key_;
}

// required bytes RSAenc_key = 3;
inline bool BufferPacketMessage::has_rsaenc_key() const {
  return _has_bit(2);
}
inline void BufferPacketMessage::clear_rsaenc_key() {
  if (rsaenc_key_ != &_default_rsaenc_key_) {
    rsaenc_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& BufferPacketMessage::rsaenc_key() const {
  return *rsaenc_key_;
}
inline void BufferPacketMessage::set_rsaenc_key(const ::std::string& value) {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  rsaenc_key_->assign(value);
}
inline void BufferPacketMessage::set_rsaenc_key(const char* value) {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  rsaenc_key_->assign(value);
}
inline void BufferPacketMessage::set_rsaenc_key(const void* value, size_t size) {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  rsaenc_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketMessage::mutable_rsaenc_key() {
  _set_bit(2);
  if (rsaenc_key_ == &_default_rsaenc_key_) {
    rsaenc_key_ = new ::std::string;
  }
  return rsaenc_key_;
}

// required bytes AESenc_message = 4;
inline bool BufferPacketMessage::has_aesenc_message() const {
  return _has_bit(3);
}
inline void BufferPacketMessage::clear_aesenc_message() {
  if (aesenc_message_ != &_default_aesenc_message_) {
    aesenc_message_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& BufferPacketMessage::aesenc_message() const {
  return *aesenc_message_;
}
inline void BufferPacketMessage::set_aesenc_message(const ::std::string& value) {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  aesenc_message_->assign(value);
}
inline void BufferPacketMessage::set_aesenc_message(const char* value) {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  aesenc_message_->assign(value);
}
inline void BufferPacketMessage::set_aesenc_message(const void* value, size_t size) {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  aesenc_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BufferPacketMessage::mutable_aesenc_message() {
  _set_bit(3);
  if (aesenc_message_ == &_default_aesenc_message_) {
    aesenc_message_ = new ::std::string;
  }
  return aesenc_message_;
}

// required .packethandler.MessageType type = 5;
inline bool BufferPacketMessage::has_type() const {
  return _has_bit(4);
}
inline void BufferPacketMessage::clear_type() {
  type_ = 1;
  _clear_bit(4);
}
inline packethandler::MessageType BufferPacketMessage::type() const {
  return static_cast< packethandler::MessageType >(type_);
}
inline void BufferPacketMessage::set_type(packethandler::MessageType value) {
  GOOGLE_DCHECK(packethandler::MessageType_IsValid(value));
  _set_bit(4);
  type_ = value;
}

// -------------------------------------------------------------------

// BufferPacket

// repeated .packethandler.GenericPacket owner_info = 1;
inline int BufferPacket::owner_info_size() const {
  return owner_info_.size();
}
inline void BufferPacket::clear_owner_info() {
  owner_info_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >&
BufferPacket::owner_info() const {
  return owner_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >*
BufferPacket::mutable_owner_info() {
  return &owner_info_;
}
inline const ::packethandler::GenericPacket& BufferPacket::owner_info(int index) const {
  return owner_info_.Get(index);
}
inline ::packethandler::GenericPacket* BufferPacket::mutable_owner_info(int index) {
  return owner_info_.Mutable(index);
}
inline ::packethandler::GenericPacket* BufferPacket::add_owner_info() {
  return owner_info_.Add();
}

// repeated .packethandler.GenericPacket messages = 2;
inline int BufferPacket::messages_size() const {
  return messages_.size();
}
inline void BufferPacket::clear_messages() {
  messages_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >&
BufferPacket::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::packethandler::GenericPacket >*
BufferPacket::mutable_messages() {
  return &messages_;
}
inline const ::packethandler::GenericPacket& BufferPacket::messages(int index) const {
  return messages_.Get(index);
}
inline ::packethandler::GenericPacket* BufferPacket::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::packethandler::GenericPacket* BufferPacket::add_messages() {
  return messages_.Add();
}

// -------------------------------------------------------------------

// ValidatedBufferPacketMessage

// required bytes sender = 1;
inline bool ValidatedBufferPacketMessage::has_sender() const {
  return _has_bit(0);
}
inline void ValidatedBufferPacketMessage::clear_sender() {
  if (sender_ != &_default_sender_) {
    sender_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidatedBufferPacketMessage::sender() const {
  return *sender_;
}
inline void ValidatedBufferPacketMessage::set_sender(const ::std::string& value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_sender(const char* value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_sender(const void* value, size_t size) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_sender() {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  return sender_;
}

// required bytes message = 2;
inline bool ValidatedBufferPacketMessage::has_message() const {
  return _has_bit(1);
}
inline void ValidatedBufferPacketMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidatedBufferPacketMessage::message() const {
  return *message_;
}
inline void ValidatedBufferPacketMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_message(const void* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// required bytes index = 3;
inline bool ValidatedBufferPacketMessage::has_index() const {
  return _has_bit(2);
}
inline void ValidatedBufferPacketMessage::clear_index() {
  if (index_ != &_default_index_) {
    index_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ValidatedBufferPacketMessage::index() const {
  return *index_;
}
inline void ValidatedBufferPacketMessage::set_index(const ::std::string& value) {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_index(const char* value) {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  index_->assign(value);
}
inline void ValidatedBufferPacketMessage::set_index(const void* value, size_t size) {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  index_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidatedBufferPacketMessage::mutable_index() {
  _set_bit(2);
  if (index_ == &_default_index_) {
    index_ = new ::std::string;
  }
  return index_;
}

// required .packethandler.MessageType type = 4;
inline bool ValidatedBufferPacketMessage::has_type() const {
  return _has_bit(3);
}
inline void ValidatedBufferPacketMessage::clear_type() {
  type_ = 1;
  _clear_bit(3);
}
inline packethandler::MessageType ValidatedBufferPacketMessage::type() const {
  return static_cast< packethandler::MessageType >(type_);
}
inline void ValidatedBufferPacketMessage::set_type(packethandler::MessageType value) {
  GOOGLE_DCHECK(packethandler::MessageType_IsValid(value));
  _set_bit(3);
  type_ = value;
}

// -------------------------------------------------------------------

// ContactInfo

// optional bytes name = 1;
inline bool ContactInfo::has_name() const {
  return _has_bit(0);
}
inline void ContactInfo::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ContactInfo::name() const {
  return *name_;
}
inline void ContactInfo::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ContactInfo::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ContactInfo::set_name(const void* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional bytes birthday = 2;
inline bool ContactInfo::has_birthday() const {
  return _has_bit(1);
}
inline void ContactInfo::clear_birthday() {
  if (birthday_ != &_default_birthday_) {
    birthday_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ContactInfo::birthday() const {
  return *birthday_;
}
inline void ContactInfo::set_birthday(const ::std::string& value) {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void ContactInfo::set_birthday(const char* value) {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void ContactInfo::set_birthday(const void* value, size_t size) {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_birthday() {
  _set_bit(1);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}

// optional bytes office_number = 3;
inline bool ContactInfo::has_office_number() const {
  return _has_bit(2);
}
inline void ContactInfo::clear_office_number() {
  if (office_number_ != &_default_office_number_) {
    office_number_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ContactInfo::office_number() const {
  return *office_number_;
}
inline void ContactInfo::set_office_number(const ::std::string& value) {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  office_number_->assign(value);
}
inline void ContactInfo::set_office_number(const char* value) {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  office_number_->assign(value);
}
inline void ContactInfo::set_office_number(const void* value, size_t size) {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  office_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_office_number() {
  _set_bit(2);
  if (office_number_ == &_default_office_number_) {
    office_number_ = new ::std::string;
  }
  return office_number_;
}

// optional bytes gender = 4;
inline bool ContactInfo::has_gender() const {
  return _has_bit(3);
}
inline void ContactInfo::clear_gender() {
  if (gender_ != &_default_gender_) {
    gender_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ContactInfo::gender() const {
  return *gender_;
}
inline void ContactInfo::set_gender(const ::std::string& value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void ContactInfo::set_gender(const char* value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void ContactInfo::set_gender(const void* value, size_t size) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_gender() {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  return gender_;
}

// optional int32 country = 5;
inline bool ContactInfo::has_country() const {
  return _has_bit(4);
}
inline void ContactInfo::clear_country() {
  country_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 ContactInfo::country() const {
  return country_;
}
inline void ContactInfo::set_country(::google::protobuf::int32 value) {
  _set_bit(4);
  country_ = value;
}

// optional bytes city = 6;
inline bool ContactInfo::has_city() const {
  return _has_bit(5);
}
inline void ContactInfo::clear_city() {
  if (city_ != &_default_city_) {
    city_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& ContactInfo::city() const {
  return *city_;
}
inline void ContactInfo::set_city(const ::std::string& value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ContactInfo::set_city(const char* value) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void ContactInfo::set_city(const void* value, size_t size) {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_city() {
  _set_bit(5);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  return city_;
}

// optional int32 language = 7;
inline bool ContactInfo::has_language() const {
  return _has_bit(6);
}
inline void ContactInfo::clear_language() {
  language_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 ContactInfo::language() const {
  return language_;
}
inline void ContactInfo::set_language(::google::protobuf::int32 value) {
  _set_bit(6);
  language_ = value;
}

// -------------------------------------------------------------------

// ContactNotification

// required int32 action = 1;
inline bool ContactNotification::has_action() const {
  return _has_bit(0);
}
inline void ContactNotification::clear_action() {
  action_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 ContactNotification::action() const {
  return action_;
}
inline void ContactNotification::set_action(::google::protobuf::int32 value) {
  _set_bit(0);
  action_ = value;
}

// optional .packethandler.ContactInfo contact = 2;
inline bool ContactNotification::has_contact() const {
  return _has_bit(1);
}
inline void ContactNotification::clear_contact() {
  if (contact_ != NULL) contact_->::packethandler::ContactInfo::Clear();
  _clear_bit(1);
}
inline const ::packethandler::ContactInfo& ContactNotification::contact() const {
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
}
inline ::packethandler::ContactInfo* ContactNotification::mutable_contact() {
  _set_bit(1);
  if (contact_ == NULL) contact_ = new ::packethandler::ContactInfo;
  return contact_;
}

// -------------------------------------------------------------------

// InstantFileNotification

// required bytes ser_mdm = 1;
inline bool InstantFileNotification::has_ser_mdm() const {
  return _has_bit(0);
}
inline void InstantFileNotification::clear_ser_mdm() {
  if (ser_mdm_ != &_default_ser_mdm_) {
    ser_mdm_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& InstantFileNotification::ser_mdm() const {
  return *ser_mdm_;
}
inline void InstantFileNotification::set_ser_mdm(const ::std::string& value) {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  ser_mdm_->assign(value);
}
inline void InstantFileNotification::set_ser_mdm(const char* value) {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  ser_mdm_->assign(value);
}
inline void InstantFileNotification::set_ser_mdm(const void* value, size_t size) {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  ser_mdm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstantFileNotification::mutable_ser_mdm() {
  _set_bit(0);
  if (ser_mdm_ == &_default_ser_mdm_) {
    ser_mdm_ = new ::std::string;
  }
  return ser_mdm_;
}

// required bytes ser_dm = 2;
inline bool InstantFileNotification::has_ser_dm() const {
  return _has_bit(1);
}
inline void InstantFileNotification::clear_ser_dm() {
  if (ser_dm_ != &_default_ser_dm_) {
    ser_dm_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& InstantFileNotification::ser_dm() const {
  return *ser_dm_;
}
inline void InstantFileNotification::set_ser_dm(const ::std::string& value) {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  ser_dm_->assign(value);
}
inline void InstantFileNotification::set_ser_dm(const char* value) {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  ser_dm_->assign(value);
}
inline void InstantFileNotification::set_ser_dm(const void* value, size_t size) {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  ser_dm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstantFileNotification::mutable_ser_dm() {
  _set_bit(1);
  if (ser_dm_ == &_default_ser_dm_) {
    ser_dm_ = new ::std::string;
  }
  return ser_dm_;
}

// required bytes filename = 3;
inline bool InstantFileNotification::has_filename() const {
  return _has_bit(2);
}
inline void InstantFileNotification::clear_filename() {
  if (filename_ != &_default_filename_) {
    filename_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& InstantFileNotification::filename() const {
  return *filename_;
}
inline void InstantFileNotification::set_filename(const ::std::string& value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void InstantFileNotification::set_filename(const char* value) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void InstantFileNotification::set_filename(const void* value, size_t size) {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstantFileNotification::mutable_filename() {
  _set_bit(2);
  if (filename_ == &_default_filename_) {
    filename_ = new ::std::string;
  }
  return filename_;
}

// -------------------------------------------------------------------

// PrivateShareNotification

// required bytes name = 1;
inline bool PrivateShareNotification::has_name() const {
  return _has_bit(0);
}
inline void PrivateShareNotification::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PrivateShareNotification::name() const {
  return *name_;
}
inline void PrivateShareNotification::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PrivateShareNotification::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PrivateShareNotification::set_name(const void* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateShareNotification::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required bytes msid = 2;
inline bool PrivateShareNotification::has_msid() const {
  return _has_bit(1);
}
inline void PrivateShareNotification::clear_msid() {
  if (msid_ != &_default_msid_) {
    msid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PrivateShareNotification::msid() const {
  return *msid_;
}
inline void PrivateShareNotification::set_msid(const ::std::string& value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline void PrivateShareNotification::set_msid(const char* value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline void PrivateShareNotification::set_msid(const void* value, size_t size) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateShareNotification::mutable_msid() {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  return msid_;
}

// required bytes public_key = 3;
inline bool PrivateShareNotification::has_public_key() const {
  return _has_bit(2);
}
inline void PrivateShareNotification::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PrivateShareNotification::public_key() const {
  return *public_key_;
}
inline void PrivateShareNotification::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void PrivateShareNotification::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void PrivateShareNotification::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateShareNotification::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes private_key = 4;
inline bool PrivateShareNotification::has_private_key() const {
  return _has_bit(3);
}
inline void PrivateShareNotification::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PrivateShareNotification::private_key() const {
  return *private_key_;
}
inline void PrivateShareNotification::set_private_key(const ::std::string& value) {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void PrivateShareNotification::set_private_key(const char* value) {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void PrivateShareNotification::set_private_key(const void* value, size_t size) {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateShareNotification::mutable_private_key() {
  _set_bit(3);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// repeated bytes admins = 5;
inline int PrivateShareNotification::admins_size() const {
  return admins_.size();
}
inline void PrivateShareNotification::clear_admins() {
  admins_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrivateShareNotification::admins() const {
  return admins_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrivateShareNotification::mutable_admins() {
  return &admins_;
}
inline const ::std::string& PrivateShareNotification::admins(int index) const {
  return admins_.Get(index);
}
inline ::std::string* PrivateShareNotification::mutable_admins(int index) {
  return admins_.Mutable(index);
}
inline void PrivateShareNotification::set_admins(int index, const ::std::string& value) {
  admins_.Mutable(index)->assign(value);
}
inline void PrivateShareNotification::set_admins(int index, const char* value) {
  admins_.Mutable(index)->assign(value);
}
inline ::std::string* PrivateShareNotification::add_admins() {
  return admins_.Add();
}
inline void PrivateShareNotification::add_admins(const ::std::string& value) {
  admins_.Add()->assign(value);
}
inline void PrivateShareNotification::add_admins(const char* value) {
  admins_.Add()->assign(value);
}
inline void PrivateShareNotification::set_admins(int index, const void* value, size_t size) {
  admins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void PrivateShareNotification::add_admins(const void* value, size_t size) {
  admins_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated bytes readonlys = 6;
inline int PrivateShareNotification::readonlys_size() const {
  return readonlys_.size();
}
inline void PrivateShareNotification::clear_readonlys() {
  readonlys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrivateShareNotification::readonlys() const {
  return readonlys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrivateShareNotification::mutable_readonlys() {
  return &readonlys_;
}
inline const ::std::string& PrivateShareNotification::readonlys(int index) const {
  return readonlys_.Get(index);
}
inline ::std::string* PrivateShareNotification::mutable_readonlys(int index) {
  return readonlys_.Mutable(index);
}
inline void PrivateShareNotification::set_readonlys(int index, const ::std::string& value) {
  readonlys_.Mutable(index)->assign(value);
}
inline void PrivateShareNotification::set_readonlys(int index, const char* value) {
  readonlys_.Mutable(index)->assign(value);
}
inline ::std::string* PrivateShareNotification::add_readonlys() {
  return readonlys_.Add();
}
inline void PrivateShareNotification::add_readonlys(const ::std::string& value) {
  readonlys_.Add()->assign(value);
}
inline void PrivateShareNotification::add_readonlys(const char* value) {
  readonlys_.Add()->assign(value);
}
inline void PrivateShareNotification::set_readonlys(int index, const void* value, size_t size) {
  readonlys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void PrivateShareNotification::add_readonlys(const void* value, size_t size) {
  readonlys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// required bytes dir_db_key = 7;
inline bool PrivateShareNotification::has_dir_db_key() const {
  return _has_bit(6);
}
inline void PrivateShareNotification::clear_dir_db_key() {
  if (dir_db_key_ != &_default_dir_db_key_) {
    dir_db_key_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& PrivateShareNotification::dir_db_key() const {
  return *dir_db_key_;
}
inline void PrivateShareNotification::set_dir_db_key(const ::std::string& value) {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  dir_db_key_->assign(value);
}
inline void PrivateShareNotification::set_dir_db_key(const char* value) {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  dir_db_key_->assign(value);
}
inline void PrivateShareNotification::set_dir_db_key(const void* value, size_t size) {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  dir_db_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrivateShareNotification::mutable_dir_db_key() {
  _set_bit(6);
  if (dir_db_key_ == &_default_dir_db_key_) {
    dir_db_key_ = new ::std::string;
  }
  return dir_db_key_;
}

// -------------------------------------------------------------------

// InstantMessage

// required bytes sender = 1;
inline bool InstantMessage::has_sender() const {
  return _has_bit(0);
}
inline void InstantMessage::clear_sender() {
  if (sender_ != &_default_sender_) {
    sender_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& InstantMessage::sender() const {
  return *sender_;
}
inline void InstantMessage::set_sender(const ::std::string& value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void InstantMessage::set_sender(const char* value) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void InstantMessage::set_sender(const void* value, size_t size) {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstantMessage::mutable_sender() {
  _set_bit(0);
  if (sender_ == &_default_sender_) {
    sender_ = new ::std::string;
  }
  return sender_;
}

// required bytes message = 2;
inline bool InstantMessage::has_message() const {
  return _has_bit(1);
}
inline void InstantMessage::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& InstantMessage::message() const {
  return *message_;
}
inline void InstantMessage::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void InstantMessage::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void InstantMessage::set_message(const void* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstantMessage::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// required int32 date = 3;
inline bool InstantMessage::has_date() const {
  return _has_bit(2);
}
inline void InstantMessage::clear_date() {
  date_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 InstantMessage::date() const {
  return date_;
}
inline void InstantMessage::set_date(::google::protobuf::int32 value) {
  _set_bit(2);
  date_ = value;
}

// optional .packethandler.ContactNotification contact_notification = 4;
inline bool InstantMessage::has_contact_notification() const {
  return _has_bit(3);
}
inline void InstantMessage::clear_contact_notification() {
  if (contact_notification_ != NULL) contact_notification_->::packethandler::ContactNotification::Clear();
  _clear_bit(3);
}
inline const ::packethandler::ContactNotification& InstantMessage::contact_notification() const {
  return contact_notification_ != NULL ? *contact_notification_ : *default_instance_->contact_notification_;
}
inline ::packethandler::ContactNotification* InstantMessage::mutable_contact_notification() {
  _set_bit(3);
  if (contact_notification_ == NULL) contact_notification_ = new ::packethandler::ContactNotification;
  return contact_notification_;
}

// optional .packethandler.InstantFileNotification instantfile_notification = 5;
inline bool InstantMessage::has_instantfile_notification() const {
  return _has_bit(4);
}
inline void InstantMessage::clear_instantfile_notification() {
  if (instantfile_notification_ != NULL) instantfile_notification_->::packethandler::InstantFileNotification::Clear();
  _clear_bit(4);
}
inline const ::packethandler::InstantFileNotification& InstantMessage::instantfile_notification() const {
  return instantfile_notification_ != NULL ? *instantfile_notification_ : *default_instance_->instantfile_notification_;
}
inline ::packethandler::InstantFileNotification* InstantMessage::mutable_instantfile_notification() {
  _set_bit(4);
  if (instantfile_notification_ == NULL) instantfile_notification_ = new ::packethandler::InstantFileNotification;
  return instantfile_notification_;
}

// optional .packethandler.PrivateShareNotification privateshare_notification = 6;
inline bool InstantMessage::has_privateshare_notification() const {
  return _has_bit(5);
}
inline void InstantMessage::clear_privateshare_notification() {
  if (privateshare_notification_ != NULL) privateshare_notification_->::packethandler::PrivateShareNotification::Clear();
  _clear_bit(5);
}
inline const ::packethandler::PrivateShareNotification& InstantMessage::privateshare_notification() const {
  return privateshare_notification_ != NULL ? *privateshare_notification_ : *default_instance_->privateshare_notification_;
}
inline ::packethandler::PrivateShareNotification* InstantMessage::mutable_privateshare_notification() {
  _set_bit(5);
  if (privateshare_notification_ == NULL) privateshare_notification_ = new ::packethandler::PrivateShareNotification;
  return privateshare_notification_;
}

// -------------------------------------------------------------------

// StoreMessagesResult

// required bytes result = 1;
inline bool StoreMessagesResult::has_result() const {
  return _has_bit(0);
}
inline void StoreMessagesResult::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreMessagesResult::result() const {
  return *result_;
}
inline void StoreMessagesResult::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreMessagesResult::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void StoreMessagesResult::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreMessagesResult::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// required int32 stored_msgs = 2;
inline bool StoreMessagesResult::has_stored_msgs() const {
  return _has_bit(1);
}
inline void StoreMessagesResult::clear_stored_msgs() {
  stored_msgs_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 StoreMessagesResult::stored_msgs() const {
  return stored_msgs_;
}
inline void StoreMessagesResult::set_stored_msgs(::google::protobuf::int32 value) {
  _set_bit(1);
  stored_msgs_ = value;
}

// repeated bytes failed = 3;
inline int StoreMessagesResult::failed_size() const {
  return failed_.size();
}
inline void StoreMessagesResult::clear_failed() {
  failed_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StoreMessagesResult::failed() const {
  return failed_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StoreMessagesResult::mutable_failed() {
  return &failed_;
}
inline const ::std::string& StoreMessagesResult::failed(int index) const {
  return failed_.Get(index);
}
inline ::std::string* StoreMessagesResult::mutable_failed(int index) {
  return failed_.Mutable(index);
}
inline void StoreMessagesResult::set_failed(int index, const ::std::string& value) {
  failed_.Mutable(index)->assign(value);
}
inline void StoreMessagesResult::set_failed(int index, const char* value) {
  failed_.Mutable(index)->assign(value);
}
inline ::std::string* StoreMessagesResult::add_failed() {
  return failed_.Add();
}
inline void StoreMessagesResult::add_failed(const ::std::string& value) {
  failed_.Add()->assign(value);
}
inline void StoreMessagesResult::add_failed(const char* value) {
  failed_.Add()->assign(value);
}
inline void StoreMessagesResult::set_failed(int index, const void* value, size_t size) {
  failed_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline void StoreMessagesResult::add_failed(const void* value, size_t size) {
  failed_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// -------------------------------------------------------------------

// CreateMSIDResult

// required bytes result = 1;
inline bool CreateMSIDResult::has_result() const {
  return _has_bit(0);
}
inline void CreateMSIDResult::clear_result() {
  if (result_ != &_default_result_) {
    result_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CreateMSIDResult::result() const {
  return *result_;
}
inline void CreateMSIDResult::set_result(const ::std::string& value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void CreateMSIDResult::set_result(const char* value) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void CreateMSIDResult::set_result(const void* value, size_t size) {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateMSIDResult::mutable_result() {
  _set_bit(0);
  if (result_ == &_default_result_) {
    result_ = new ::std::string;
  }
  return result_;
}

// optional bytes name = 2;
inline bool CreateMSIDResult::has_name() const {
  return _has_bit(1);
}
inline void CreateMSIDResult::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CreateMSIDResult::name() const {
  return *name_;
}
inline void CreateMSIDResult::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateMSIDResult::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateMSIDResult::set_name(const void* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateMSIDResult::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional bytes private_key = 3;
inline bool CreateMSIDResult::has_private_key() const {
  return _has_bit(2);
}
inline void CreateMSIDResult::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CreateMSIDResult::private_key() const {
  return *private_key_;
}
inline void CreateMSIDResult::set_private_key(const ::std::string& value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void CreateMSIDResult::set_private_key(const char* value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void CreateMSIDResult::set_private_key(const void* value, size_t size) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateMSIDResult::mutable_private_key() {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// optional bytes public_key = 4;
inline bool CreateMSIDResult::has_public_key() const {
  return _has_bit(3);
}
inline void CreateMSIDResult::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CreateMSIDResult::public_key() const {
  return *public_key_;
}
inline void CreateMSIDResult::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateMSIDResult::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateMSIDResult::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateMSIDResult::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}


}  // namespace packethandler
#endif  // PROTOBUF_packet_2eproto__INCLUDED
